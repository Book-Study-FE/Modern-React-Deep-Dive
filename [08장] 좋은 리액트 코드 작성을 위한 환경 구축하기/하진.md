# 8.1 ESLint를 활용한 정적 코드 분석

ESLint: 정적 코드 분석 도구 <br/>
정적 코드 분석: 코드의 실행과는 별개로 코드 그 자체만으로 코드 스멜(버그를 야기할 수 있는 코드)을 찾아내어 수정하는 것

## 8.1.1 ESLint 살펴보기

### ESLint의 코드 분석 방법

- ESLint: 자바스립트 코드를 정적 분석해 잠재적인 문제를 발견하고, 수정까지 도와주는 도구
- 어떻게 자바스크립트 코드를 읽어서 분석하는가?

  1.  **자바스크립트 코드를 문자열로 읽는다.**
  2.  **자바스크립트 코드를 분석할 수 있는 파서(parser)로 도구를 구조화한다.**
      <details><summary><b>파서(parser)로 구조화하는 과정</b></summary>

           - ESLint는 자바스크립트를 분석하는 파서로 espree를 사용

             ```js
             function hello(str) {}
             ```

           - 위와 같은 자바스크립트 코드를 espree로 분석하면 아래와 같이 JSON 형태로 구조화된 결과를 얻을 수 있음
           `json

      {
      "type": "Program",
      "start": 0,
      "end": 22,
      "range": [0, 22],
      "body": [
      {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 22,
      "range": [0, 22],
      "id": {
      "type": "Identifier",
      "start": 9,
      "end": 14,
      "range": [9, 14],
      "name": "hello"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
      {
      "type": "Identifier",
      "start": 15,
      "end": 18,
      "range": [15, 18],
      "name": "str"
      }
      ],
      "body": {
      "type": "BlockStatement",
      "start": 20,
      "end": 22,
      "range": [20, 22],
      "body": []
      }
      }
      ],
      "sourceType": "module"
      }
      ` - 단순히 변수인지, 함수인지 등만 파악하는 것이 아니라 코드의 정확한 위치와 같은 세세한 정보까지 분석 - 이런 자세한 정보가 있어야만 ESLint나 Prettier같은 도구가 코드의 줄바꿈, 들여쓰기 등을 파악할 수 있음
      </details>

  3.  **2번에서 구조화한 트리를 AST(Abstract Syntax Tree)라 하고, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.**
      <details><summary><b>규칙과 대조하는 과정</b></summary>

      - 어떤 코드가 잘못된 코드이며 어떻게 수정해야할지 정하는 과정
      - debugger의 사용을 금지하는 규칙을 만들기 위한 과정 예시

        ```json
        // 1. debugger를 espree로 분석하면 어떻게 변환되는지 파악
        {
          "type": "Program",
          "body": [
            {
              "type": "DebuggerStatement",
              "range": [0, 8]
            }
          ],
          "sourceType": "module",
          "range": [0, 8]
        }
        ```

        ```js
        // 2. debugger 사용을 제한하는 no-debugger 규칙을 확인
        module.exports = {
          meta: {
            // meta: 해당 규칙과 관련된 메타 정보를 나타냄
            type: "problem",
            docs: {
              // 문서화에 필요한 정보
              description: "Disallow the use of `debugger`",
              recommended: true,
              u: "https://eslint.org/docs/rules/no-debugger",
            },
            fixable: null, // 수정 가능한지 여부
            schema: [],
            messages: {
              // 규칙을 어겼을 때 반환하는 경고 문구
              unexpected: "Unexpected 'debugger' statement.",
            },
          },
          create(context) {
            // 실제 코드의 문제점을 확인
            return {
              DebuggerStatement(node) {
                context.report({
                  node,
                  messageId: "unexpected",
                });
              },
            };
          },
        };
        ```

      - create에 있는 함수는 espree로 만들어진 AST 트리를 순회
      - 여기서 선언한 특정 조건을 만족하는 코드를 찾고, 이러한 작업을 코드 전체에서 반복
      - 즉, DebuggerStatement를 만나면 해당 노드를 report해서 debugger를 사용했음을 알림

      </details>

  4.  **규칙과 대조했을 때 이를 위반한 코드를 알리거나(report) 수정한다(fix).**

## 8.1.2 eslint-plugin과 eslint-config

### eslint-plugin

- 특정 프레임워크나 도메인과 관련된 규칙을 모아놓는 패키지
- 예시
  - eslint-plugin-import: 자바스크립트에서 다른 모듈을 불러오는 import와 관련된 다양한 규칙을 제공
  - eslint-plugin-react: 리액트 관련 규칙
- 이 규칙들에서 export하는 create 함수를 살펴보면 에러 해결에 도움을 얻을 수 있음

### eslint-config

- eslint-plugin을 묶어서 완벽하게 한 세트로 제공하는 패키지
- 한 조직에서 여러 프로젝트에 ESLint의 규칙을 일괄적으로 적용하고자 할 때
- 여러 프로젝트에 걸쳐 동일하게 사용할 수 있는 ESLint 관련 설정을 제공하는 패키지
- ESLint 설정은 복잡하기 때문에, 대부분의 경우 일부 IT 기업들에서 공개한 잘 만들어진 eslint-config를 설치해서 사용하는 것이 일반적

### 바로 사용할 수 있는 대표적인 eslint-config 라이브러리

#### eslint-config-airbnb

- 에어비앤비에서 만든 eslint-config
- 가장 많이 쓰이고 유명한 대표적인 eslint-config

### titicaca/triple-config-kit

- 스타트업 개발사인 인터파크트리플에서 개발
- 한국 커뮤니티에서 운영되며, 유지 보수가 활발하고 많이 쓰이는 eslint-config

### eslint-config-next

- Next.js 프레임워크를 사용하는 프로젝트에서 쓸 수 있는 eslint-config

## 8.1.3 나만의 ESLint 규칙 만들기

- 이미 존재하는 규칙을 커스터마이징해서 적용하기
- 완전히 새로운 규칙 만들기

## 8.1.4

### Prettier와의 충돌

- Prettier: 포매팅을 도와주는 도구
  - ESLint와 마찬가지로 코드를 정적 분석해서 문제를 해결하는 점은 동일하지만, 지향하는 목표가 다름
  - ESLint: 잠재적인 문제가 될 수 있는 부분을 분석
  - Prettier: 줄바꿈, 들여쓰기, 작은따옴표, 큰따옴표 등을 담당
  - 자바스크립트 뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에 적용 가능
- 두 도구가 충돌을 일으킬 수 있음: ESLint에서도 Prettier에서 처리하는 작업을 처리할 수 있기 때문
  - 두가지 모두를 자바스크립트 코드에서 실행한다면 충돌 규칙으로 인해 에러 발생
- 해결 방법
  - 충돌되지 않게끔 선언하기
    - Prettier에서는 제공하는 규칙을 어기지 않도록하고, ESLint에서는 해당 규칙을 끔
  - 자바스크립트는 ESLint에, 그 외 파일은 Prettier에서 작업하기

### 규칙에 대한 예외 처리

- 일부 코드에서 특정 규칙을 임시로 제외시키고 싶을 때 eslint-disable- 주석 사용

### ESLint 버전 충돌

- 설치하고자 하는 eslint-config, eslint-plugin이 지원하는 ESLint 버전을 확인
- 설치하고자 하는 프로젝트에서 ESLint 버전을 어떻게 지원하고 있는지 확인

# 8.2 테스트 라이브러리

## 8.2.1 React Testing Library란?

- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리
- 리액트를 기반으로 한 테스트를 수행하기 위해 만들어짐
- 브라우저를 직접 실행해 눈으로 확인하지 않아도 리액트 컴포넌트가 원하는대로 렌더링되고 있는지 확인할 수 있음

## 8.2.2 자바스크립트 테스트의 기초

```js
funtion sum(a,b) {
  return a + b
}
```

이 함수에 대한 테스트 코드를 작성한다면

```js
// 테스트 1
// 함수를 실행했을 때의 실제 결과
let actual = sum(1, 2);
// 함수를 실행했을 때 기대하는 결과
let expected = 3;

if (expectd !== actual) {
  throw new Error(`${expected} is not equal to ${actual}`);
}
```

- 테스트 코드 작성 방식
  1. 테스트할 함수나 모듈을 선정한다.
  2. 함수나 모듈이 반환하길 기대하는 값을 적는다.
  3. 함수나 모듈의 실제 반환값을 적는다.
  4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다.
  5. 기대하는 결과를 반환한다면 테스트 성공, 기대와 다른 결과를 반환하면 에러를 던진다.
- `asser` 모듈

  - Node.js에서 기본적으로 제공하는 모듈
  - 테스트 코드가 예상대로 작동한다고 주장하는 코드를 작성하면, 이 코드의 성공 여부에 따라 테스트 통과 또는 실패를 반환

    ```js
    const assert = require("assert");

    function sum(a, b) {
      return a + b;
    }

    assert.equal(sum(1, 2), 3);
    assert.equal(sum(2, 2), 4);
    ```

  - 이처럼 테스트 결과를 확인할 수 있도록 도와주는 라이브러리: 어설션(assertion) 라이브러리
    - equal, should, expect, chai, deepEqual, notEqual, throws 등 다양한 메서드를 제공

- 테스트 코드를 읽기 쉽게 만들어주는 프레임워크
  - 어설션을 기반으로 테스트를 수행하며, 여기에 추가로 테스트 코드 작성자에게 도움이 될만한 정보를 알려주는 역할
  - Jest, Mocha, Karma, Jasmine 등

## 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

- 리액트 컴포넌트 테스트 순서
  1. 컴포넌트를 렌더링한다.
  2. 컴포넌트에서 특정 액션을 수행한다.
  3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다.

### 프로젝트 생성

```ts
npx create-react app react-test --template typescript
```

- create-react-app에는 이미 react-testing-library가 포함돼있으므로 별도 설치가 필요 없음
- 위처럼 프로젝트를 생성하면 `App.test.tsx` 파일이 생성
- App.test.tsx가 App.tsx에서 테스트하는 내용
  - <App />를 렌더링한다.
  - 렌더링하는 컴포넌트 내부에서 "learn react"라는 문자열을 가진 DOM 요소를 찾는다.
  - expect(linkElement).toBeInTheDocument()라는 어설션을 활용해 2번에서 찾은 요소가 documnet 내부에 있는지 확인한다.

### 정적 컴포넌트

- 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 정적 컴포넌트를 테스트
- 테스트를 원하는 컴포넌트를 렌더리안 다음, 테스트를 원하는 요소를 찾아 원하는 테스트를 수행
- toHaveAttribute, toBeVisible 등 다양한 메서드를 사용해 테스트를 수행

### 동적 컴포넌트

- 상태값이 있는 동적 컴포넌트를 테스트
- type, click, dbclick, clear 등 사용자 작동을 흉내내는 메서드를 활용하여 사용자 작동을 재현

### 비동기 이벤트가 발생하는 컴포넌트

- fetch가 실행되는 컴포넌트 테스트
- MSW(Mock Service Worker): Node.js나 브라우저에서 모두 사용할 수 있는 모킹 라이브러리
  - 테스트를 수행할 때마다 모든 경우를 새롭게 모킹해야하는 문제를 해결
  - Node.js나 브라우저에서는 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행
  - 이 요청을 MSW가 중간에 감지하고, 미리 준비한 모킹 데이터를 제공하는 방식
  - fetch의 모든 기능을 그대로 사용하면서도 응답에 대해서만 모킹할 수 있음

### 사용자 정의 훅 테스트

- `react-hooks-testing-library`를 활용해 훅을 테스트
- 테스트를 위한 컴포넌트를 생성하지 않아도 훅을 간편하게 테스트
- renderHook 함수에서 훅을 편리하게 테스트하기 위한 rerender, unmount 등의 함수도 제공

## 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

- 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것이 중요
- 테스트 코드는 소프트웨어의 코드를 100% 커버하기 위해 작성하는 것이 아님
- 단순 코드 작성만으로는 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확신을 얻기 위해 작성하는 것

## 8.2.6 그 외 테스트

- 유닛 테스트: 각 코드나 컴포넌트가독립적으로 분리된 환경에서 의도된대로 적확히 작동하는지 검증하는 테스트
- 통합 테스트: 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드(E2E 테스트): 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트
