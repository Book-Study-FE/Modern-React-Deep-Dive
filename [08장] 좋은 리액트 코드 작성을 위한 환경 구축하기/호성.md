# 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

## 8.1 ESLint를 활용한 정적 코드 분석

### 8.1.1 ESLint 살펴보기

ESLint가 코드를 분석하는 방법은 아래와 같다.

1. 자바스크립트 코드를 문자열로 읽는다.
2. 자바스크립트 코드를 분석할 수 있는 parser로 코드를 구조화한다.
3. 2번에서 구조화 한 트리를 AST(Asbstract Synatx Tree)라 하며, 이 트리를 기준으로 각종 규칙과 대조한다.
4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나 수정한다.

ESLint의 기본 parser는 `espree` 이다. 분석 결과를 바탕으로 코드가 잘못 됬는지, 어떻게 수정해야하는지 판단해야 하는데 이것을 `규칙(Rules)` 이라고 한다. 이 특정한 규칙의 모음을 `plugins`라고 한다.

### 8.1.2 eslint-plugin과 eslint-config

eslint-plugin 접두사의 패키지는 규칙을 모아놓은 패키지, eslint-config 접두사의 패키지는 eslint-plugin을 한데 묶어서 완벽하게 한 세트로 제공하는 패키지 이다.
일반적으로 eslint-config 를 설치해서 당장 사용한다.

### 8.1.3 나만의 ESLint 규칙 만들기

조직 내 규칙이나 코드 변화로 인해 일괄적으로 고쳐야하는 경우, ESLint 규칙을 생성해서 효율적으로 고칠 수 있다. 규칙은 하나씩 만들어 배포하는 것은 불가능하며, 반드시 eslint-plugin 형태로 규칙을 묶음으로 배포하는 것만 가능하다.

### 8.1.4 주의할 점

#### Prettier와 충돌

ESLint가 잠재적인 코드 문제를 분석해 준다면, Prettier는 코드 포맷팅과 관련된 작업을 하는 툴이다. 해결 방법은 아래와 같다.

- 서로 규칙이 충돌되지 않게 규칙을 잘 선언한다.
- 자바스크립트나 타입스크립트는 ESLint에 그외 파일을 Prettier에 맡긴다.

#### react-hooks/no-exhaustive-deps

useEffect나 useMemo 같은 훅의 의존성 배열을 제대로 선언했는지 확인하는 역할을 한다. 총 1,800여줄로 구성되어 있는 규칙이다. 이 규칙을 무시하는것은 대부분 위험한 발상이다.

- **괜찮다고 임의로 판단한 경우,** 의도치 않은 곳에서 잠재적인 버그를 야기할 수 있다.
- **의존성 배열이 너무 긴 경우,** 함수 내부가 너무 길다는 말을 의미한다. 함수를 쪼개 가독성과 안정성을 확보해야한다.
- **마운트 시점에 한 번만 실행하고 싶은 경우,** 상태와 관계없이 한번만 실행해야 하는 것이 있다면 컴포넌트에 존재해야 할 이유가 없다. 적절한 위치로 옮겨서 사용하자

#### ESLint 버전 충돌

이런 문제로 인해 ESLint 공식문서에서는 ESLint를 peerDependencies로 설정해두라고 말하고 있다.

## 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

백엔드와 프론트 테스트 방법론이 사뭇 다르다. 백엔드는 화이트박스 테스트를 주로 하며, 프론트엔드는 블랙박스 테스트를 주로 한다. 유저는 개발자의 의도대로 움직이기 않기 때문에 유저의 인터렉션을 최대한 예측해서 확인을 해야하며 단순 함수부터 사용자의 동작을 흉내내는 테스트 등 여러 테스트가 있다.

화이트박스 테스트 : 내부 코드나 로직을 이해하고 테스트하는 방식이다. 개발자가 직접 코드 흐름, 조건문, 루프 등을 보고 테스트하기 때문에 오류 원인을 파악하기 쉽고, 상세한 검증이 가능하다.

블랙박스 테스트 : 내부 구현을 보지 않고, 외부에서 주어진 입력과 출력만 확인하며 시스템을 테스트한다. 사용자 입장에서 기능이 예상대로 작동하는지만을 확인하기 때문에 내부 구조를 몰라도 테스트가 가능하다. 

http://www.jidum.com/jidums/view.do?jidumId=588

### 8.2.1. React Testing Library

Dom Testing Library를 기반으로 만들어졌다. 브라우저에서 실행시키지 않아도 Node에서 DOM을 불러오고 조작할 수 있다.

Dom Testing Library는 jsdom을 기반으로 하고 있음

- jsdom은 순수하게 자바스크립트로 작성되어 있다.
- HTML이 없는 자바스크립트만 존재하는 환경에서 HTML과 DOM을 사용할 수 있도록 해줌

좋은 테스트 코드는 다양한 테스트 코드가 작성되고 통과하는 것뿐만 아니라 어떤 테스트가 무엇을 테스트하는지 일목요연하게 보여주는 것도 중요함

Jest가 유지보수되고 있지 않았다가 메타에서 오픈소스 재단으로 관리 주체가 바뀜


### 8.2.2. 자바스크립트 테스트의 기초

기본적인 테스트 방식은 아래와 같은 방식을 거친다.

1. 테스트할 함수나 모듈을 선정한다
2. 함수나 모듈이 반환하길 기대하는 값을 만든다.
3. 함수나 모듈의 실제 반환값을 적는다.
4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다.
5. 기대값과 같으면 성공 다르면 실패를 반환한다.

이런 테스트 결과를 확인할 수 있게 도와주는 라이브러리를 `어설션(assertion)`이라 하며, 테스팅 프레임워크들은 이를 기반으로 테스트를 수행한다.

### 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

리액트 컴포넌트 테스트는 다음과 같은 순서로 진행된다.

1. 컴포넌트를 렌더링한다.
2. 필요하다면 컴포넌트의 특정 액션을 수행한다.
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과 실제를 비교한다.

리액트 컴포넌트가하는 일반적인 시나리오는 특정한 무언가를 지난 HTML 요소가 있는지 여부다. 이를 확인하는 방법은 크게 아래와 같이 3가지 정도가 있다.

- **getBy,** 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러
- **findBy,** getBy와 유사하나 차이점은 Promise를 반환. 즉 비동기로 찾는다.
- **queryBy,** 인수 조건에 맞는 요소를 반환하고, 찾지 못하면 null 반환

테스트 파일은 검사할 파일과 같은 디렉토리에 넣는다

#### 데이터셋

HTML의 특정 요소와 관련된 임의 정보를 추가할 수 있는 HTML 속성. `data-testid` 같은 속성을 추가하여 유용하게 사용할 수 있다.

#### 정적 컴포넌트
jest 메소드 정리
beforeEach : 각 테스트(it)을 수행하기 전에 실행하는 함수
describe : 비슷한 속성을 가진 테스트를 하나의 그룹으로 묶음
it : test와 동일하며, test의 축약어이다.
testId : 리액트 테스팅 라이브러리의 예약어로, get 등의 선택자로 선택하기 어렵거나 곤론한 요소를 선택

#### 동적 컴포넌트

useState 등의 통해 상태변경도 같이 일어나는 컴포넌트의 경우이다.

- userEvent.type, 사용자가 타이핑을 하는 것을 흉내내는 메소드. fireEvent를 순차적으로 실행한다.

#### 비동기 컴포넌트

MSW를 이용한 모킹 테스트 방식
MSW는 브라우저에서는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현한다

### 8.2.4 사용자 정의 훅 테스트하기

사용자 정의 훅도 동일하게 테스트 가능하다. 훅을 렌더링 하기 위해서는 `renderHook`을 사용해야 한다. initialProps를 지정하여 renderHook의 함수 초기값을 지정할 수 있다.

### 8.2.5 테스트를 작성하기에 앞서 고려해야할 점

테스트 커버리지를 100%까지 끌어올릴 상황은 생각보다 드물고 테스트 커버리지는 만능이 아니다. 
테스트 코드를 작성하기 전 가장 중요한 부분은 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것 이다. 
TDD를 차용하더라도 모든 상황을 커버해 테스트 작성하는 것은 불가능하다
가장 핵심인 부분부터 하나씩 작성해 나가는게 중요하다.

### 8.2.6 그 밖의 해볼만한 여러 가지 테스트

- 유닛테스트
- 통합 테스트
- E2E 테스트
  E2E 테스트는 Cypress 같은 외부 라이브러리의 힘을 빌려야 한다.

### 8.2.7 정리

테스트가 이뤄야할 목표는 애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것 하나이다.