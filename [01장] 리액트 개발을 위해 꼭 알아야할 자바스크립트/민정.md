## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

### 1) 원시 타입

- 객체가 아닌 다른 모든 타입. 메서드를 갖지 않음

#### undefined

- 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않는 인수에 자동으로 할당되는 값

#### null

- 아직 값이 없거나 비어있는 값을 표현할 때 사용
- `typeof`로 `null`을 확인했을 때 해당 타입이 아닌 `'object'`라는 결과 반환

#### boolean

- 참(true)과 거짓(false)만을 가질 수 있는 데이터 타입
- 주로 조건문에서 많이 쓰임

#### Number

- 정수와 실수를 구분해서 저장하는 다른 언어와 다르게, 자바스크립트는 모든 숫자를 하나의 타입에 저장
- -(2^^53 -1) ~ (2^^53 - 1) 사이의 값을 저장 가능

#### Bigint

- number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 것
- number의 한계를 넘어서 더 큰 숫자 저장 가능

#### String

- 텍스트 타입의 데이터를 저장하기 위해 사용
- 한 쌍의 작은따옴표('')나 큰따옴표(""), 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱(``)으로 표현 가능
- 문자열이 원시 타입이며, 한번 문자열이 생성되면 스 문자열을 변경할 수 없음

#### Symbol

- ES6에서 새롭게 추가된 7번째 타입, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어짐
- 심벌을 생성하려면 반드시 Symbol()을 사용해야 함

### 2) 객체 타입

- 7가지 원시 타입 이외의 모든 것, 배열, 함수, 정규식, 클래스 등이 포함됨
- 참조를 전달한다고 해서 참조 타입

```jsx
const hello1 = function () {};

const hello2 = function () {};

hello1 === hello2; // false (참조가 다르기 때문에)
```

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식
- 동등 비교를 할 때 차이를 만드는 원인이 됨

#### 원시 타입

- 불변 형태의 값으로, 변수 할당 시점에 메모리 영역을 차지하고 저장ehla

```jsx
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true (hello의 hellow world 값이 hi에 복사해 전달되었기 떄문)
```

#### 객체 타입

- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장됨
- 값을 복사할 때도 값이 아닌 참조를 전달하게 됨.

```jsx
// 다음 객체들은 완벽하게 동일한 내용 갖고 있음
var hello = {
  greet: "hello world",
};

var hi = {
  greet: "hello world",
};

console.log(hello === hi); // false (동등 비교 결과 false)
console.log(hello.greet === hi.greet); // true (원시값인 내부 속성 값을 비교하면 동일)
```

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드

  - == vs. Object.is
    - == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환 한 후에 비교
    - 5 == '5'처럼 형변환 후에 값이 동일하다면 true 반환. Object.is는 이러한 작업을 하지 않고, ===와 동일하게 타입이 다르면 false
  - === vs. Object.is : Object.is가 좀 더 정확히 비교함

  ```jsx
  -0 === +0; // true
  Object.is(-0, +0); // false
  ```

- Object.is를 사용하더라도 객체 비교에는 별 차이 없고 앞어 이야기한 객체 비교 원리와 동등함
- Object.is는 ES6에서 새로 도입된 비교 문법
- 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어졌지만 객체 간 비교에 있어서는 여전히 ===와 동일하게 동작

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is
- ES6에서 제공하는 기능이기 떄문에 폴리필(Polyfill) 함께 사용
  - 폴리필(Polyfill) : 브라우저가 이해할 수 없는 코드에 대하여, 이해할 수 있는 코드 소스를 제공하는 것
- 리액트에서는 ObjectIs를 기반으로 동등 비교를 하는 `shallowEqual` 함수 사용. 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 다양하게 사용됨
- 얕은 비교 : 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교함

```jsx
Object.is({ hello: "world" }, { hello: "world" }); // false (참조가 다른 객체 비교 불가능)

shallowEqual({ hello: "world" }, { hello: "world" }); // true (객체의 1 depth까지 비교 가능)
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false (2 depth까지는 비교할 방법 없으므로 false 반환)
```

- 객체의 얕은 비교까지만 구현한 이유는 리액트에서 사용하는 JSX props는 객체이고 props만 일차적으로 비교하면 되기 때문

## 1.2 함수

### 1.2.1 함수란 무엇인가?

- 자바스크립트에서는 작업을 수행하거나 값을 계산하는 등의 과정을 표현, 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

```jsx
function sum(a, b) {
  return a + b;
}

sum(10, 24); // 34
```

- 리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것 알 수 있음

```jsx
function Component(props) {
  return <div>{props.hello}</div>;
}
```

### 1.2.2 함수를 정의하는 4가지 방법

#### 1) 함수 선언문

- 자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식

```jsx
function add(a, b) {
  return a + b;
}
```

- 표현식이 아닌 일반문으로 분류

#### 2) 함수 표현식

- 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
- 자바스크립트에서 함수는 일급 객체. 다른 함수의 매개 변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가능하기 때문

```jsx
// 함수를 변수에 할당
const sum = function (a, b) {
  return a + b;
};

sum(10, 24); // 34
```

- 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적. 코드를 봤을 때 혼란을 방지하기 위함
- 함수에 이름을 주는 것은 함수 호출에 도움이 전혀 안되는, 코드를 읽는데 방해되는 요소

##### 함수 표현식과 선언 식의 차이

- 두 가지 방식의 가장 큰 차이는 호이스팅(hoisting) 여부
- 함수의 호이스팅

  - 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징 의미

  ```jsx
  hello(); // hello

  function hello() {
    console.log("hello");
  }

  hello(); // hello
  ```

  - 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미
  - 함수 표현식은 함수를 변수에 할당했기 때문에 , 런타임 이전에 undefined로 초기화되고, 할당문이 실행되는 시점(런타임 시점)에 함수가 할당되어 작동함

  ```jsx
  console.log(typeof hello === "undefined"); // true

  hello(); // Uncaught TypeError: hellow is not a function

  var hello = function () {
    console.log(hello);
  };

  hello();
  ```

#### 3) Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");

add(10, 24); // 34
```

- 코드 작성 관점에서 보면 매개변수, 함수의 몸통을 전부 문자열로 작성해야 하기 때문에 코드의 양이 길어지면 혼란스러워질 것
- 함수의 클로저 생성되지 않음

#### 4) 화살표 함수

- ES6에서 새롭게 추가된 함수 생성 방식
- function이라는 키워드 대신 => 라는 화살표를 활용

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

- 앞서 언급한 함수 생성 방식과의 큰 차이점

  - 화살표 함수에서는 constructor을 사용할 수 없음. 즉, 생성자 함수로 화살표 함수를 사용하는 것 불가능
  - 화살표 함수에는 arguments 존재하지 않음
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않음. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 됨. 즉, 별도의 작업을 추가로 하지 않고 this에 접근할 수 있음
  - 화살표 함수는 this가 선언되는 시점에서 이미 상위 스코프로 결정되어 있지만, 일반 함수는 호출하는 런타임 시점에 셯덜괴응 this를 그대로 따름

- 따라서 화살표 함수는 단순히 일반 함수의 축약형이라고 보기엔 무리가 있으므로, this를 사용할 수 밖에 없는 클래스 컴포넌트 내부에서 각별한 주의 필요

### 1.2.3 다양한 함수 살펴보기

#### 1) 즉시 실행 함수

- Immediately Invoked Function Expression, 일반적으로는 IIFE라고 부름
- 말 그대로 함수를 정의하고 그 순간 즉시 실핻되는 함수 의미

```jsx
(function (a, b) {
  return a + b;
})(10, 24); // 34
```

- 한 번 선언하고 호출된 이후부터는 더 이상 재호출 불가능하기 때문에 일반적으로는 이름을 붙이지 않음
- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용 가능하다는 장점

#### 2) 고차 함수

- 함수를 인수로 받거나 결과로 새로운 함수 반환시킬 수 있는 역할을 하는 함수

```jsx
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2, 4, 6]
```

### 1.2.4 함수를 만들 때 주의해야 할 사항

#### 1) 함수의 부수 효과를 최대한 억제하라

- 함수의 부수 효과 : 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
- 부수 효과가 없는 함수는 순수 함수, 존재하는 함수는 비순수 함수
- 순수 함수는 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환하고 작동 와중에 외부에 어떠한 영향도 미쳐서는 안됨
- 순수한 함수는 언제 실행되든 항상 결과가 동일하기 때문에 예측 가능하며 안정적
- 비순수 함수를 만드는 것은 애플리케이션을 만들면서 피할 수 없지만 최대한 억제할 수 있는 방향으로 함수를 설계해야 함

#### 2) 가능한 한 함수를 작게 만들어라

#### 3) 누구나 이해할 수 있는 이름을 붙여라

- 가능한 한 함수 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋음
- 리액트에서 사용하는 `useEffect`나 `useCallback` 등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙여주는 것도 가독성에 도움이 됨
