## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

### 1) 원시 타입

- 객체가 아닌 다른 모든 타입. 메서드를 갖지 않음

#### undefined

- 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않는 인수에 자동으로 할당되는 값

#### null

- 아직 값이 없거나 비어있는 값을 표현할 때 사용
- `typeof`로 `null`을 확인했을 때 해당 타입이 아닌 `'object'`라는 결과 반환

#### boolean

- 참(true)과 거짓(false)만을 가질 수 있는 데이터 타입
- 주로 조건문에서 많이 쓰임

#### Number

- 정수와 실수를 구분해서 저장하는 다른 언어와 다르게, 자바스크립트는 모든 숫자를 하나의 타입에 저장
- -(2^^53 -1) ~ (2^^53 - 1) 사이의 값을 저장 가능

#### Bigint

- number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 것
- number의 한계를 넘어서 더 큰 숫자 저장 가능

#### String

- 텍스트 타입의 데이터를 저장하기 위해 사용
- 한 쌍의 작은따옴표('')나 큰따옴표(""), 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱(``)으로 표현 가능
- 문자열이 원시 타입이며, 한번 문자열이 생성되면 스 문자열을 변경할 수 없음

#### Symbol

- ES6에서 새롭게 추가된 7번째 타입, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어짐
- 심벌을 생성하려면 반드시 Symbol()을 사용해야 함

### 2) 객체 타입

- 7가지 원시 타입 이외의 모든 것, 배열, 함수, 정규식, 클래스 등이 포함됨
- 참조를 전달한다고 해서 참조 타입

```jsx
const hello1 = function () {};

const hello2 = function () {};

hello1 === hello2; // false (참조가 다르기 때문에)
```

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식
- 동등 비교를 할 때 차이를 만드는 원인이 됨

#### 원시 타입

- 불변 형태의 값으로, 변수 할당 시점에 메모리 영역을 차지하고 저장ehla

```jsx
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true (hello의 hellow world 값이 hi에 복사해 전달되었기 떄문)
```

#### 객체 타입

- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장됨
- 값을 복사할 때도 값이 아닌 참조를 전달하게 됨.

```jsx
// 다음 객체들은 완벽하게 동일한 내용 갖고 있음
var hello = {
  greet: "hello world",
};

var hi = {
  greet: "hello world",
};

console.log(hello === hi); // false (동등 비교 결과 false)
console.log(hello.greet === hi.greet); // true (원시값인 내부 속성 값을 비교하면 동일)
```

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드

  - == vs. Object.is
    - == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환 한 후에 비교
    - 5 == '5'처럼 형변환 후에 값이 동일하다면 true 반환. Object.is는 이러한 작업을 하지 않고, ===와 동일하게 타입이 다르면 false
  - === vs. Object.is : Object.is가 좀 더 정확히 비교함

  ```jsx
  -0 === +0; // true
  Object.is(-0, +0); // false
  ```

- Object.is를 사용하더라도 객체 비교에는 별 차이 없고 앞어 이야기한 객체 비교 원리와 동등함
- Object.is는 ES6에서 새로 도입된 비교 문법
- 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어졌지만 객체 간 비교에 있어서는 여전히 ===와 동일하게 동작

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is
- ES6에서 제공하는 기능이기 떄문에 폴리필(Polyfill) 함께 사용
  - 폴리필(Polyfill) : 브라우저가 이해할 수 없는 코드에 대하여, 이해할 수 있는 코드 소스를 제공하는 것
- 리액트에서는 ObjectIs를 기반으로 동등 비교를 하는 `shallowEqual` 함수 사용. 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 다양하게 사용됨
- 얕은 비교 : 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교함

```jsx
Object.is({ hello: "world" }, { hello: "world" }); // false (참조가 다른 객체 비교 불가능)

shallowEqual({ hello: "world" }, { hello: "world" }); // true (객체의 1 depth까지 비교 가능)
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false (2 depth까지는 비교할 방법 없으므로 false 반환)
```

- 객체의 얕은 비교까지만 구현한 이유는 리액트에서 사용하는 JSX props는 객체이고 props만 일차적으로 비교하면 되기 때문
