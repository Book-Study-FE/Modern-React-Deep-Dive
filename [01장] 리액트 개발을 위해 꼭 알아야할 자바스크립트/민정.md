## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

### 1) 원시 타입

- 객체가 아닌 다른 모든 타입. 메서드를 갖지 않음

#### undefined

- 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않는 인수에 자동으로 할당되는 값

#### null

- 아직 값이 없거나 비어있는 값을 표현할 때 사용
- `typeof`로 `null`을 확인했을 때 해당 타입이 아닌 `'object'`라는 결과 반환

#### boolean

- 참(true)과 거짓(false)만을 가질 수 있는 데이터 타입
- 주로 조건문에서 많이 쓰임

#### Number

- 정수와 실수를 구분해서 저장하는 다른 언어와 다르게, 자바스크립트는 모든 숫자를 하나의 타입에 저장
- -(2^53 -1) ~ (2^53 - 1) 사이의 값을 저장 가능

#### Bigint

- number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 것
- number의 한계를 넘어서 더 큰 숫자 저장 가능

#### String

- 텍스트 타입의 데이터를 저장하기 위해 사용
- 한 쌍의 작은따옴표('')나 큰따옴표(""), 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱(``)으로 표현 가능
- 문자열이 원시 타입이며, 한번 문자열이 생성되면 스 문자열을 변경할 수 없음

#### Symbol

- ES6에서 새롭게 추가된 7번째 타입, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어짐
- 심벌을 생성하려면 반드시 Symbol()을 사용해야 함

### 2) 객체 타입

- 7가지 원시 타입 이외의 모든 것, 배열, 함수, 정규식, 클래스 등이 포함됨
- 참조를 전달한다고 해서 참조 타입

```jsx
const hello1 = function () {};

const hello2 = function () {};

hello1 === hello2; // false (참조가 다르기 때문에)
```

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식
- 동등 비교를 할 때 차이를 만드는 원인이 됨

#### 원시 타입

- 불변 형태의 값으로, 변수 할당 시점에 메모리 영역을 차지하고 저장

```jsx
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true (hello의 hellow world 값이 hi에 복사해 전달되었기 떄문)
```

#### 객체 타입

- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장됨
- 값을 복사할 때도 값이 아닌 참조를 전달하게 됨.

```jsx
// 다음 객체들은 완벽하게 동일한 내용 갖고 있음
var hello = {
  greet: "hello world",
};

var hi = {
  greet: "hello world",
};

console.log(hello === hi); // false (동등 비교 결과 false)
console.log(hello.greet === hi.greet); // true (원시값인 내부 속성 값을 비교하면 동일)
```

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드

  - == vs. Object.is
    - == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환 한 후에 비교
    - 5 == '5'처럼 형변환 후에 값이 동일하다면 true 반환. Object.is는 이러한 작업을 하지 않고, ===와 동일하게 타입이 다르면 false
  - === vs. Object.is : Object.is가 좀 더 정확히 비교함

  ```jsx
  -0 === +0; // true
  Object.is(-0, +0); // false
  ```

- Object.is를 사용하더라도 객체 비교에는 별 차이 없고 앞어 이야기한 객체 비교 원리와 동등함
- Object.is는 ES6에서 새로 도입된 비교 문법
- 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어졌지만 객체 간 비교에 있어서는 여전히 ===와 동일하게 동작

### 1.1.4 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is
- ES6에서 제공하는 기능이기 떄문에 폴리필(Polyfill) 함께 사용
  - 폴리필(Polyfill) : 브라우저가 이해할 수 없는 코드에 대하여, 이해할 수 있는 코드 소스를 제공하는 것
- 리액트에서는 ObjectIs를 기반으로 동등 비교를 하는 `shallowEqual` 함수 사용. 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 다양하게 사용됨
- 얕은 비교 : 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교함

```jsx
Object.is({ hello: "world" }, { hello: "world" }); // false (참조가 다른 객체 비교 불가능)

shallowEqual({ hello: "world" }, { hello: "world" }); // true (객체의 1 depth까지 비교 가능)
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false (2 depth까지는 비교할 방법 없으므로 false 반환)
```

- 객체의 얕은 비교까지만 구현한 이유는 리액트에서 사용하는 JSX props는 객체이고 props만 일차적으로 비교하면 되기 때문

## 1.2 함수

### 1.2.1 함수란 무엇인가?

- 자바스크립트에서는 작업을 수행하거나 값을 계산하는 등의 과정을 표현, 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

```jsx
function sum(a, b) {
  return a + b;
}

sum(10, 24); // 34
```

- 리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것 알 수 있음

```jsx
function Component(props) {
  return <div>{props.hello}</div>;
}
```

### 1.2.2 함수를 정의하는 4가지 방법

#### 1) 함수 선언문

- 자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식

```jsx
function add(a, b) {
  return a + b;
}
```

- 표현식이 아닌 일반문으로 분류

#### 2) 함수 표현식

- 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
- 자바스크립트에서 함수는 일급 객체. 다른 함수의 매개 변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가능하기 때문

```jsx
// 함수를 변수에 할당
const sum = function (a, b) {
  return a + b;
};

sum(10, 24); // 34
```

- 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적. 코드를 봤을 때 혼란을 방지하기 위함
- 함수에 이름을 주는 것은 함수 호출에 도움이 전혀 안되는, 코드를 읽는데 방해되는 요소

##### 함수 표현식과 선언 식의 차이

- 두 가지 방식의 가장 큰 차이는 호이스팅(hoisting) 여부
- 함수의 호이스팅

  - 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징 의미

  ```jsx
  hello(); // hello

  function hello() {
    console.log("hello");
  }

  hello(); // hello
  ```

  - 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미
  - 함수 표현식은 함수를 변수에 할당했기 때문에 , 런타임 이전에 undefined로 초기화되고, 할당문이 실행되는 시점(런타임 시점)에 함수가 할당되어 작동함

  ```jsx
  console.log(typeof hello === "undefined"); // true

  hello(); // Uncaught TypeError: hellow is not a function

  var hello = function () {
    console.log(hello);
  };

  hello();
  ```

#### 3) Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");

add(10, 24); // 34
```

- 코드 작성 관점에서 보면 매개변수, 함수의 몸통을 전부 문자열로 작성해야 하기 때문에 코드의 양이 길어지면 혼란스러워질 것
- 함수의 클로저 생성되지 않음

#### 4) 화살표 함수

- ES6에서 새롭게 추가된 함수 생성 방식
- function이라는 키워드 대신 => 라는 화살표를 활용

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

- 앞서 언급한 함수 생성 방식과의 큰 차이점

  - 화살표 함수에서는 constructor을 사용할 수 없음. 즉, 생성자 함수로 화살표 함수를 사용하는 것 불가능
  - 화살표 함수에는 arguments 존재하지 않음
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않음. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 됨. 즉, 별도의 작업을 추가로 하지 않고 this에 접근할 수 있음
  - 화살표 함수는 this가 선언되는 시점에서 이미 상위 스코프로 결정되어 있지만, 일반 함수는 호출하는 런타임 시점에 셯덜괴응 this를 그대로 따름

- 따라서 화살표 함수는 단순히 일반 함수의 축약형이라고 보기엔 무리가 있으므로, this를 사용할 수 밖에 없는 클래스 컴포넌트 내부에서 각별한 주의 필요

### 1.2.3 다양한 함수 살펴보기

#### 1) 즉시 실행 함수

- Immediately Invoked Function Expression, 일반적으로는 IIFE라고 부름
- 말 그대로 함수를 정의하고 그 순간 즉시 실핻되는 함수 의미

```jsx
(function (a, b) {
  return a + b;
})(10, 24); // 34
```

- 한 번 선언하고 호출된 이후부터는 더 이상 재호출 불가능하기 때문에 일반적으로는 이름을 붙이지 않음
- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용 가능하다는 장점

#### 2) 고차 함수

- 함수를 인수로 받거나 결과로 새로운 함수 반환시킬 수 있는 역할을 하는 함수

```jsx
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2, 4, 6]
```

### 1.2.4 함수를 만들 때 주의해야 할 사항

#### 1) 함수의 부수 효과를 최대한 억제하라

- 함수의 부수 효과 : 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
- 부수 효과가 없는 함수는 순수 함수, 존재하는 함수는 비순수 함수
- 순수 함수는 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환하고 작동 와중에 외부에 어떠한 영향도 미쳐서는 안됨
- 순수한 함수는 언제 실행되든 항상 결과가 동일하기 때문에 예측 가능하며 안정적
- 비순수 함수를 만드는 것은 애플리케이션을 만들면서 피할 수 없지만 최대한 억제할 수 있는 방향으로 함수를 설계해야 함

#### 2) 가능한 한 함수를 작게 만들어라

#### 3) 누구나 이해할 수 있는 이름을 붙여라

- 가능한 한 함수 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋음
- 리액트에서 사용하는 `useEffect`나 `useCallback` 등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙여주는 것도 가독성에 도움이 됨

## 1.3 클래스

### 1.3.1 클래스란 무엇인가?

- 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것
- 클래스를 활용하면 객체를 만드는 데 필요한 데이터나 이를 조작하는 코드를 추상화해 객체 생성을 더욱 편리하게 할 수 있음

#### 1) constructor

- 객체를 생성하는 데 사용하는 특수한 메서드
- 단 하나만 존재할 수 있으며, 여러 개 사용하면 에러 발생
- 별 다르게 수행할 작업이 없다면 생략하는 것도 가능

#### 2) 프로퍼티

- 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값 의미

#### 3) getter와 setter

- getter : 클래스에서 무언가 값을 가져올 때 사용되며 get을 앞에 붙이고 뒤이어서 getter의 이름을 선언해야 함.
- setter : 클래스 필드에 값을 할당할 때 사용. 마찬가지로 set이라는 키워드를 먼저 선언하고, 뒤이어서 이름을 붙이면 됨

```jsx
class Car {
  constructor (name) {
    this.name = name
  }
}

get firstCharacter () {
  return this.name[0]
}

set firstCharacter (char) {
  this.name = [char, ...this.name.slice(1)].join('')
}

const myCar = new Car('자동차')

myCar.firstCharacter // 자

// '차'를 할당한다.
myCar.firstCharacter = '차'

console.log(myCar.firstCharacter, myCar.name) // 차, 자동차
```

#### 4) 인스턴스 메서드

- 클래스 내부에서 선언한 메서드
- 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 함

#### 5) 정적 메서드

- 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드
- this에 접근할 수는 없지만 인스턴스를 생성하지 않아도 사용할 수 있음
- 생성하지 않아도 접근할 수 있기 때문에 객체를 생성하지 않더라도 여러 곳에서 재사용 가능
- 애플리케이션 전역에서 사용하는 유틸 함수를 정적 메서드로 많이 활용

#### 6) 상속

- 리액트에서 클래스 컴포넌트를 만들기 위해서 extends React.Component, extends React.PureComponent를 선언함
- extends는 기존 클래스를 상속받아서 자식 클래스에서 이 상속받은 클래스를 기반으로 확장하는 개념

### 1.3.2 클래스와 함수의 관계

- 클래스는 ES6에서 등장한 개념으로, 이전에는 프로토 타입을 활용해 클래스의 작동 방식을 동일하게 구현 가능했음
- 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것
- 객체지향 언어를 사용하던 다른 프로그래머가 좀 더 자바스크립트에 접근하기 쉽게 만들어주는, 일종의 문법적 설탕(syntactic sugar)의 역할을 한다고 볼 수 있음

## 1.4 클로저

### 1.4.1 클로저의 정의

- MDN : 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합

  - 선언된 어휘적 환경
    - 변수가 코드 내부에서 어디서 선언됐는지를 말함
    - 호출되는 방식에 따라 동적으로 결정되는 this와 다르게 코드가 작성된 순간에 정적으로 결정됨

  ```jsx
  function add() {
    const a = 10;
    function innerAdd() {
      const b = 20;
      console.log(a + b);
    }
    innerAdd(); // 30
  }

  add();
  ```

  ### 1.4.2 변수의 유효 범위, 스코프

  #### 1) 전역 스코프

  - 전역 레벨에 선언하는 것
  - 전역(global)이라는 이름에서 알 수 있듯, 이 스코프에서 변수를 선언하면 어디서든 호출할 수 있게 됨

  ```jsx
  var global = "global scope";

  function hello() {
    console.log(global);
  }

  console.log(global); // global scope
  hello(); // global scope
  console.log(global == window.global); // true
  ```

  - 전역 스코프와 hello 스코프 모두에서 global 변수에 접근할 수 있는 것 확인 가능

  #### 2) 함수 스코프

  - 자바스크립트는 기본적으로 함수 레벨 스코프를 따름
  - {} 블록이 스코프 범위를 결정하지 않음

  ### 1.4.3 클로저의 활용

  #### 1) 클로저의 활용

  - 전역 스코프는 어디서든 원하는 값을 꺼내올 수 있다는 장점이 있지만, 반대로 얘기하면 누구든 접근할 수 있고 수정할 수 있다는 뜻
  - 클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있음

  #### 2) 리액트에서의 클로저

  - 클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 useState

  ```jsx
  function Component() {
    const [state, setState] = useState();

    function handleClick() {
      // useState 호출은 위에서 끝났지만
      // setState는 계속 내부의 최신값(prev) 알고 있음
      // 클로저를 활용했기 때문에
      setState((prev) => prev + 1);
    }

    //...
  }
  ```

  ### 1.4.4 주의할 점

  - 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생
  - 클로저가 선언된 순간 내부 함수는 외부 함수의 선언적 환경을 기억하고 있어야 하므로 이를 어디에서 사용하는지 여부에 관계없이 저장
  - 클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹는 결과를 야기할 수 있고, 마찬가지로 클로저 사용을 적절한 스코프로 가둬두지 않는다면 성능에 악영향 미침

## 1.5 이벤트 루프와 비동기 통신의 이해

### 1.5.1 싱글 스레드 자바스크립트

- 프로세스 : 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위. 즉, 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것
- 스레드 : 하나의 프로그램에는 하나의 프로세스만이 할당되므로 이러한 작업을 수행하기 어려워서 탄생한 더 작은 실행 단위
- 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행 가능해지면서 동시 다발적인 작업 처리할 수 있게 됨
- 자바스크립트가 싱글 스레드로 설계된 이유
  - 멀티 스레드는 내부적으로 처리가 복잡함
  - 동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 동시성 문제 발생할 수 있음
  - 각각 격리돼 있는 프로세스와 다르게, 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 달느 스레드에서 동시에 문제가 일어날 수 있음
- 자바스크립트가 싱글 스레드라는 것은 자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 의미

### 1.5.2 이벤트 루프란?

#### 1) 호출 스택과 이벤트 루프

- 호출 스택 : 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택

```jsx
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();
```

- 위의 코드는 foo를 호출하고, 내부에서 bar, baz를 순차적으로 호출하는 구조로 되어있음

  - 호출 스택에 쌓이고 비워지는 순서
    1. `foo()`가 호출 스택에 먼저 들어감
    2. `foo()` 내부에 `console.log`가 존재하므로 호출 스택에 들어감
    3. 2의 실행이 완료된 이후에 다음 코드로 넘어감 (아직 `foo()`는 존재)
    4. `bar()`가 호출 스택에 들어감
    5. `bar()`의 내부에 `console.log`가 존재하므로 호출 스택에 들어감
    6. 5의 실행이 완료된 이후에 다음 코드로 넘어감(아직 `foo()`, `bar()`는 존재)
    7. 더 이상 `bar()`에 남은 것이 없으므로 호출 스택에서 제거됨(아직 `foo()`는 존재)
    8. `baz()`가 호출 스택에 들어감
    9. `baz()` 내부에 `console.log`가 존재하므로 호출 스택에 들어감
    10. 9의 실행이 완료된 이후에 다음 코드로 넘어감(아직 `foo()`, `baz()`는 존재)
    11. 더 이상 `baz()`에 남은 것이 없으므로 호출 스택에서 제거(아직 foo()는 존재)
    12. 더 이상 `foo()`에 남은 것이 없으므로 호출 스택에서 제거
    13. 호출 스택 완전히 비워짐

- 호출 스택이 비어 있는지 여부를 확인하는 것 이벤트 루프
- 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업들이 있는지 확인하고, 수행해야 할 코드가 잇다면 자바스크립트 엔진을 이용해 실행
- '코드를 실행하는 것'과 '호출 스택이 비어있는지 확인하는 것' 모두 단일 스레드에서 일어나기 때문에 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어남

- 비동기 작업의 실행 방식

```jsx
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 0); // setTimeout만 추가
  baz();
}

foo();
```

- 위의 코드는 앞의 코드와는 다르게 foo, baz, bar 순으로 출력됨

  1. `foo()`가 호출 스택에 먼저 들어감
  2. `foo()` 내부에 `console.log`가 존재하므로 호출 스택에 들어감
  3. 2의 실행이 완료된 이후에 다음 코드로 넘어감 (아직 foo()는 존재)
  4. `setTimeout(bar(), 0)`이 호출 스택에 들어감
  5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거됨
  6. `baz()`가 호출 스택에 들어감
  7. `baz()` 내부에 `console.log`가 존재하므로 호출 스택에 들어감
  8. 7의 실행이 완료된 이후에 다음 코드로 넘어감(아직 `foo()`, `baz()`는 존재)
  9. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거됨(아직 `foo()`는 존재)
  10. 더 이상 `foo()`에 남은 것이 없다면 호출 스택에서 제거됨
  11. 이제 호출 스택이 완전 비워졌음
  12. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인. 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 `bar()`를 호출 스택에 들여보냄
  13. `bar()` 내부에 console.log가 존재하므로 호출 스택에 들어감
  14. 13의 실행이 끝나고, 다음 코드로 넘어감(아직 `bar()` 존재)
  15. 더 이상 `bar()`에 남은 것이 없으므로 호출 스택에서 제거

- 태스크 큐 : 실행해야 할 태스크의 집합
- 태스크 큐는 자료 구조 큐(queue)가 아닌 set 형태 띠고 있음. 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문
- FIFO 형식인 자료 구조 큐와 달리 태스크 큐에서의 '실행해야 할 태스크'라는 것은 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미함
- 비동기 함수는 누가 수행하는가?
  - 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행
  - 별도의 스레드에서 태스크 큐에 작업을 할당에 처리하는 것은 브라우저나 Node.js의 역할
  - 이벤트 루프는 호출 스택이 비고, 콜백 실행 가능한 때가 오면 이것을 꺼내서 수행하는 역할
  - 이러한 작업들을 모두 자바스크립트 코드가 실행되는 메인 스레드에서만 이루어진다면 절대로 비동기 작업을 할 수가 없음

### 1.5.3 태스크 큐와 마이크로 태스크 큐

- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 테스크 큐와는 다른 테스크 처리
- 대표적인 마이크로 태스트는 Promise
- 마이크로 테스트 큐는 기존 테스크 큐보다 우선권을 가짐
- 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행 뒤로 밀려남

```jsx
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

setTimeout(foo, 0);

Promise.resolve().then(bar).then(baz);
```

- 예제 코드를 실행하면 bar, baz, foo 순으로 실행되므로 Promise가 우선권이 있음을 알 수 있음
  - 태스크 큐 : setTimeout, setInterval, setImmediate
  - 마이크로 태스크 큐 : process, nexTick, Promises, queueMicroTask, MutationObserver
- 랜더링은 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어남. 각 마이크로 태스크 큐 작업이 끝날 때마다 렌더링할 기회를 얻음

```jsx
<html>
  <body>
    <ul>
      <li>동기 코드: <button id="sync">0</button></li>
      <li>태스크: <button id="macrotask">0</button></li>
      <li>마이크로 태스크: <button id="microtask">0</button></li>
    </ul>

    <button id="macro_micro">모두 동시 실행</button>
  </body>
  <script>
    const button = document.getElementById('run')
    const sync = document.getElementById('sync')
    const macrotask = document.getElementById('macrotask')
    const microtask = document.getElementById('microtask')

    const macro_micro = document.getElementById('macro_micro')

    // 동기 코드로 버튼에 1부터 렌더링
    sync.addEventListener('click', function() {
      for (let i = 0; i <= 100000; i++) {
        sync.innerHTML = i
      }
    })

    // setTimeout으로 태스크 큐에 작업을 넣어서 1부터 렌더링
    macrotask.addEventListener('click', function() {
      for (let i = 0; i <= 100000; i++) {
        setTimeout(() => {
          macrotask.innerHTML = i
        }, 0)
      }
    })

    // queueMicroTask로 마이크로 태스크 큐에 넣어서 1부터 렌더링
    microtask.addEventListener('click', function() {
      for (let i = 0; i <= 100000; i++;) {
        queueMicrotask(() => {
          microtask.innerHTML = i
        })
      }
    })

    macro_micro.addEventListener('click', function () {
      for (let i = 0; i <= 100000; i++) {
        sync.innerHTML = i

        setTimeout(() => {
          macrotask.innerHTML = i
        }, 0)

        queueMicrotask(() => {
          microtask.innerHTML = i
        })
      }
    })
  </script>
</html>
```

- 위 예제 코드의 결과

  - 동기 코드는 우리가 예상했던 것처럼 해당 연산, 즉 100,000까지 숫자가 올라가기 전까지는 렌더링이 일어나지 않다가 for문이 끝나야 비로소 렌더링 기회를 얻으며 100,000이라는 숫자가 한 번에 나타남
  - 태스크 큐(setTimeout)는 모든 setTimeout 콜백이 큐에 들어가기 전까지 잠깐의 대기 시간을 가잗가 1부터 100,000까지 순차적으로 렌더링되는 것을 볼 수 있음
  - 마이크로 태스크 큐(queueMicrotask)는 동기 코드와 마찬가지로 렌더링이 전혀 일어나지 않다가 100,000까지 다 끝난 이후에야 한 번에 렌더링 일어남
  - 모든 것을 동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한 번에 100,000까지 올라가고, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링되는 것 볼 수 있음

- 이러한 작업 순서는 브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 하는 requestAnimationFrame으로도 확인 가능

```jsx
console.log("a");

setTimeout(() => {
  console.log("b");
}, 0);

Promise.resolve().then(() => {
  console.log("c");
});

window.requestAnimationFrame(() => {
  console.log("d");
});
```

- 위 코드를 실행하면 a, c, d, b 순서로 출력됨. 즉, 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어난다는 것을 알 수 있음
- 동기 코드는 물론이고 마이크로 태스크 또한 마찬가지로 렌더링에 영향을 미칠 수 있기 때문에 만약 특정 렌더링이 자바스크립트 내 무거운 작업과 연관이 있다면 이를 어떤 식으로 분리해서 사용자에게 좋은 애플리케이션 경험을 제공해 줄지 고민해 보아야 함
