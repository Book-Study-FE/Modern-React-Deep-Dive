## 1.1 자바스크립트의 동등 비교

### 1) 원시타입

1. undefined
   - 선언 후에 값이 할당되지 않은 변수
2. null
   - 값이 없어나 비어 있는 값 typeof null을 했을 때 object를 반환
3. Boolean
   - 참과 거짓만을 가질 수 있는 데이터 타입
4. Number
   - 정수와 실수를 구분해 저장하는 다른 언어와는 다르게, 자바스크립트는 숫자를 이 타입으로 모두 정의.
   - -(2^^53 -1) ~ (2^^53 - 1) 사이의 값을 저장 가능.
5. BigInt
   - number가 다룰 수 있는 숫자의 크기 제한을 극복하기 위해 ES2020에서 새롭게 나온 것. number의 한계를 넘어 더 큰 숫자를 저장 가능.
6. String
   - 문자열 타입이고, 원시 타입이며 문자열이 생성되면 그 문자열을 변경 불가하다.
7. Symbol
   - ES6에서 새롭게 추가된 7번째 타입, 중복되지 않는 고유의 값을 나타내기 위해 만들어짐.

### 2) 객체 타입

- 객체 타입은 참조를 전달한다고 해서 참조 타입
- 객체 타입은 7가지 원시 타입 이외의 모든 것, 배열, 함수, 정규식, 클래스 등이 포함된다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

const hello1 = function () {};
const hello2 = function () {};

// * 참조가 다르게 때문에
hello1 === hello2; // false
```

### 참조에 의한 전달

- 얕은 복사를 통해 객체를 가리키는 변수를 다른 변수에 할당하면, 원본의 참조 값이 복사되어 전달되고 이를 참조에 의한 전달이라고 한다. 이럴 경우 원본, 사본 중 속성 하나를 변경하면 변경된 값이 서로에게 영향을 준다.

### Object.is

- 인수 두 개가 동일한지 확인하고 반환하는 메서드
- == 비교는 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제 형변환 후 비교
- === 보다 더 엄격한 검사

```
-0 === +0 // true
Object.is(-0, +0) // false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) // true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) // true
```

### 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 Object.is이다. Object.is를 사용하여 shallwEqual 이라는 함수를 만들어 사용하는데 Object.is와의 차이점은 객체 간 얕은 비교를 한 번 더 수행 가능하다. 즉 1 depth 까지는 비교가 가능하다.
- 이렇게 객체의 얕은 비교까지 구현이 가능하게 한 이유는 jsx props는 객체이고, props만 일차적으로 비교하면 되기 때문이다.

## 1.2 함수

### 함수를 정의하는 4가지 방법

- 함수 선언문

```
function add(a, b) {
    return a + b
}
```

- 함수 표현식

```
const sum = function (a, b) {
    return a + b
}

sum(10, 24) // 34
```

- Function 생성자
  - 권장되지않는 방법

```
const add = new Function('a', 'b', 'return a + b')

add(10, 24) // 34
```

- 화살표 함수

```
const add = (a, b) => {
    return a + b
}

const add = (a, b) => a + b
```

- 화살표 함수와 앞서 언급한 함수와의 차이점

  - 화살표 함수에서는 constructor를 사용 불가
  - 화살표 함수는 arguments가 존재하지 않는다

- 즉시 실행 함수

```
(function (a, b){
    return a + b
})(10, 24); // 34
```

- 고차 함수

```
const doubledArray = [1, 2, 3].map((item) => item * 2)

doubledArray // [2, 4, 6]

// 함수를 반환하는 고차 함수의 예
const add = function(a){
    // a가 존재하는 클로저를 생성
    return function (b) {
        // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
        return a + b
    }
}
add(1)(3) // 4
```

### 함수를 만들 때 주의사항

- Side effect 최대한 억제
- 가능한 한 함수를 작게 만들어라
- 누구나 이해할 수 있는 이름을 붙여라

## 1.3 클래스

#### 클래스란?

- 객체를 만드는 템플릿

```
// Car 클래스 선언
class Car {
    // constructor는 생성자다. 최초에 생성할 때 어떤 인수를 받을지 결정할 수 있으며,
    // 객체를 초기화하는 용도로도 사용된다.
    constructor(name){
        this.name = name
    }

    // 메서드
    honk() {
        console.log(`${this.name}이 경적을 울립니다!`)
    }

    // 정적 메서드
    static hello(){
        console.log('저는 자동차입니다')
    }

    // setter
    set age(value){
        this.carAge = value
    }

    // getter
    get age(){
        return this.carAge
    }

    // Car 클래스를 활용해 car 객체를 만들었다.
    const myCar = new Car('자동차')

    // 메서드 호출
    myCar.honk()

    // 정적 메서드는 클래스에서 직접 호출한다.
    Car.hello()

    // 정적 메서드는 클래스로 만든 객체에서는 호출할 수 없다.
    //Uncaught TypeError: myCar.hello is not a function
    myCar.hello()

    // setter를 만들면 값을 할당할 수 있다.
    myCar.age = 32

    // getter로 값을 가져올 수 있다.
    console.log(myCar.age, myCar.name) // 32 자동차
}
```

### constructor

- 객체를 생성하는 데 사용하는 메서드
- 단 하나만 존재 가능

### 프로퍼티

- 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미

```
class Car{
    constructor(name){
        // 값을 받으면 내부에 프로퍼티로 할당된다.
        this.name = name
    }
}

const myCar = new Car('자동차')
```

### getter와 setter

- getter란 클래스에서 무언가 값을 가져올 때 사요
- setter란 클래스 필드에 값을 할당할 때 사용

### 인스턴스 메서드

- 클래스 내부에서 선언한 메서드
- 이 인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 함

```
class Car{
    constructor(name){
        this.name = name
    }

    // 인스턴스 메서드 정의
    hello(){
        console.log(`안녕, ${this.name}`)
    }
}

const myCar = new Car('자동차')
myCar.hello() // 안녕하세요, 자동차입니다.
```

### 정적 메서드 (static method)

- 이름으로 호출할 수 있는 메서드

```
class Car{
    static hello(){
        console.log(`안녕, ${this.name}`)
    }
}

Car.hello()
```

## 1.4 클로저

### 클로저의 정의

- 클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
- "선언된 어휘적 환경"이라는 것은, 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다.

### 스코프

- 전역 스코프
  - 어디서든 호출할수 있는 스코프
- 함수 스코프
  - {} 블록이 스코프 범위를 결정 하지 않음
  - 자바스크립트에서 스코프는, 일단 가장 가까운 스코프에서 변수가 존재하는지를 먼저 확인

### 클로저의 활용

리액트에서의 클로저 useState

```
function Component() {
	const [state, setState] = useState();

	// ...
}
```

useState의 호출은 첫 줄에서 종료 됐지만, setState는 useState 내부의 상태 값을 확인하고 업데이트 할 수 있다. 외부 함수(useState)가 자신이 선언된 외부 함수가 선언된 환경을 기억하고 있음

그렇기에 useState 호출이 끝난 상황에서도 setState를 통해 상태를 업데이트 할 수 있음

### 주의할 점

1. 스코프를 신경쓰기
2. 메모리 누수
