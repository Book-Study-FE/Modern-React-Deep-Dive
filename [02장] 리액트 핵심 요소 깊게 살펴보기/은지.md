# 2.1 JSX란?

- JSX
  - HTML, XML 외에도 다른 구문으로도 확장될 수 있게끔 고려
  - 최대한 구문을 간결하고 친숙하게 작성할 수 있도록 설계
  - 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있음
- JSX의 설계 목적
  - 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점
  - JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해 두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경

## 2.1.1 JSX의 정의

- `JSXElement`, `JSXAttributes`, `JSXChilderen`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성

### JSXElement

- JSX를 구성하는 가장 기본 요소
- HTML의 요소와 비슷한 역할

#### JSXElement가 되기 위한 요소

- `JSXOpeningElement` + `JSXClosingElement`
  - 같은 단계에 선언돼 있어야 올바른 JSX 문법으로 간주
  - 예: `<JSXElement JSXAttributes(optional)></JSXelement>`
- `JSXSelfClosingElement`
  - 요소가 시작되고 스스로 종료되는 형태
  - 내부적으로 자식을 포함할 수 없는 형태
  - 예: `<JSXElement JSXAttributes(optioanl) />`
- `JSXFragment`
  - 아무런 요소가 없는 상태
  - 예: `<>JSXChildren(optional)</>`

> 요소명을 대문자로 시작하는 이유 : 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위함

### JSXElementName

- `JSXElement`의 요소 이름으로 가능한 것

#### JSXIdentifier

- JSX 내부에서 사용할 수 있는 식별자
  - 자바스크립트 식별자 규칙과 동일
  - `<$></$>`, `<_></_>` 가능, 그 이외에 다른 특수문자 및 숫자는 불가능

#### JSXNamespaceName

- `JSXIdentifier:JSXIdentifier`의 조합
- `:`을 통해 서로 다른 식별자 이어줌
  - 두 개 이상은 불가능

```js
// 가능
function valid() {
    return <foo:bar></foo:bar>
}

// 불가능
function valid() {
    return <foo:bar:baz></foo:bar:baz>
}
```

#### JSXMemberExpression

- `JSXIdentifier.JSXIdentifier`
- `.`을 통해 서로 다른 식별자 이어줌
  - 여러 개 가능
  - `JSXNamespaceName`과 이어서 사용은 불가능

```js
// 가능
function valid() {
    return <foo.bar></foo.bar>
}

function valid() {
    return <foo.bar.baz></foo.bar.baz>
}

// 불가능
function valid() {
    return <foo:bar.baz></foo:bar.baz>
}
```

### JSXAttributes

- `JSXElement`에 부여할 수 있는 속성
  - 모든 경우에서 필수값이 아님
- `JSXSpreadAttributes` : 자바스크립트의 전개 연산자와 동일한 역할
  - `{...AssignmentExpression}` : 모든 표현식이 존재 가능 (객체, 조건문 표현식, 화살표 함수, 할당식 등)
- `JSXAttribute` : 속성을 나타내는 키와 값으로 짝을 이루어 표현
  - `JSXAttribute` : 속성의 키 값
    - `JSXIdentifier`와 `JSXNamespacedName`이 가능
    ```js
    function valid1() {
      return <foo.bar fooLbar="baz"></foo.bar>;
    }
    ```
  - `JSXAttributeValue` : 속성의 키에 할당할 수 있는 값
    - "큰따옴표로 구성된 문자열"
    - '작은따옴표로 구성된 문자열'
    - `{ AssignmentExpression }` : 자바스크립트에서 값을 할당할 때 쓰는 표현식
      - 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능
    - `JSXElement` : 다른 JSX 요소가 들어갈 수 있음
      ```js
      <Child attribute=<div>hello</div> />
      ```
  - `JSXFragment` : 값으로 별도 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있음
    - 비어 있는 형태의 `<></>` 허용

### JSXChildren

- `JSXElement`의 자식 값을 나타냄

#### JSXChild

- `JSXChildren`을 이루는 기본 단위, 0개 이상을 가질 수 있음
- `JSXTest` : {, <, >, }을 제외한 문자열 가능
  - 다른 JSX 문법과 혼동을 줄 수 있기 때문
- `JSXElement` : 값으로 다른 JSX 요소가 들어갈 수 있음
- `JSXFragment` : 값으로 빈 JSX 요소인 `<></>`가 들어갈 수 있음
- `{ JSXChildExpression (optional) }` : `JSXChildExpression`는 자바스크립트의 `AssignmentExpression`을 의미
  ```js
  export default function App() {
    return <>{(() => "foo")()}</>;
  }
  ```

### JSXStrings

- HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있음

## 2.1.2 JSX 예제

#### 유효한 형태의 JSX

```js
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕</A>

 // 자식이 없이 SelfClosingTag로 닫혀 있는 형태
 const ComponentB = <A />

 // 옵션을 { }와 전개 연산자로 넣을 수 있음
 const ComponentC = <A {...{ required: true }} />

 // 속성만 넣어도 가능
 comst ComponentD = <A required />

 // 속성과 속성값을 넣을 수 있음
 comst ComponentE = <A required = {fasle} />

 // 문자열 "", '' 가능
 cosnt ComponentF = (
    <A>
        <B text = "react" />
    </A>
 )

 // 옵션의 값으로 JSXElement 넣는 것 가능
 cosnt ComponentG = (
    <A>
        <B optionalChildren = {<>안녕하세요</>} />
    </A>
 )

 // 여러 개의 자식도 가능
 cosnt ComponentH = (
    <A>
        안녕하세요
        <B text = "react" />
    </A>
 )
```

## 2.1.3 JSX는 어떻게 자바스크립트에서 변환할까?

- JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인
  - `JSXElement`를 첫 번째 인수로 선언해 요소를 정의
  - 옵셔널인 `JSXChildren`, `JSXAttributes`, `JSXStrings`는 이후 인수로 넘겨주어 처리

#### JSX가 변환되는 특성을 활용

- `JSXElement`만 다르고 `JSXChildren`, `JSXAttributes`가 완전히 동일한 상황에서 중복 코드를 최소화할 수 있음

```js
// X
// props 여부에 따라 children 요소만 달라지는 경우
// 중복 코드 및 번거로운 삼항 연산자 처리 필요 없음
import { createElement, PropsWithChildren } from "react";

function TextOrHeading({
  isHeading,
  children,
}: PropsWithCHildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// O
// JSX가 변환되는 특성을 활용
import { createElement } from "react";

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "hi" : "span",
    { className: "text" },
    children
  );
}
```
