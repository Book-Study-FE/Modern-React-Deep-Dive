# 2.1 JSX란?

- JSX
  - HTML, XML 외에도 다른 구문으로도 확장될 수 있게끔 고려
  - 최대한 구문을 간결하고 친숙하게 작성할 수 있도록 설계
  - 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있음
- JSX의 설계 목적
  - 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점
  - JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해 두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경

## 2.1.1 JSX의 정의

- `JSXElement`, `JSXAttributes`, `JSXChilderen`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성

### JSXElement

- JSX를 구성하는 가장 기본 요소
- HTML의 요소와 비슷한 역할

#### JSXElement가 되기 위한 요소

- `JSXOpeningElement` + `JSXClosingElement`
  - 같은 단계에 선언돼 있어야 올바른 JSX 문법으로 간주
  - 예: `<JSXElement JSXAttributes(optional)></JSXelement>`
- `JSXSelfClosingElement`
  - 요소가 시작되고 스스로 종료되는 형태
  - 내부적으로 자식을 포함할 수 없는 형태
  - 예: `<JSXElement JSXAttributes(optioanl) />`
- `JSXFragment`
  - 아무런 요소가 없는 상태
  - 예: `<>JSXChildren(optional)</>`

> 요소명을 대문자로 시작하는 이유 : 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위함

### JSXElementName

- `JSXElement`의 요소 이름으로 가능한 것

#### JSXIdentifier

- JSX 내부에서 사용할 수 있는 식별자
  - 자바스크립트 식별자 규칙과 동일
  - `<$></$>`, `<_></_>` 가능, 그 이외에 다른 특수문자 및 숫자는 불가능

#### JSXNamespaceName

- `JSXIdentifier:JSXIdentifier`의 조합
- `:`을 통해 서로 다른 식별자 이어줌
  - 두 개 이상은 불가능

```js
// 가능
function valid() {
    return <foo:bar></foo:bar>
}

// 불가능
function valid() {
    return <foo:bar:baz></foo:bar:baz>
}
```

#### JSXMemberExpression

- `JSXIdentifier.JSXIdentifier`
- `.`을 통해 서로 다른 식별자 이어줌
  - 여러 개 가능
  - `JSXNamespaceName`과 이어서 사용은 불가능

```js
// 가능
function valid() {
    return <foo.bar></foo.bar>
}

function valid() {
    return <foo.bar.baz></foo.bar.baz>
}

// 불가능
function valid() {
    return <foo:bar.baz></foo:bar.baz>
}
```

### JSXAttributes

- `JSXElement`에 부여할 수 있는 속성
  - 모든 경우에서 필수값이 아님
- `JSXSpreadAttributes` : 자바스크립트의 전개 연산자와 동일한 역할
  - `{...AssignmentExpression}` : 모든 표현식이 존재 가능 (객체, 조건문 표현식, 화살표 함수, 할당식 등)
- `JSXAttribute` : 속성을 나타내는 키와 값으로 짝을 이루어 표현
  - `JSXAttribute` : 속성의 키 값
    - `JSXIdentifier`와 `JSXNamespacedName`이 가능
    ```js
    function valid1() {
      return <foo.bar fooLbar="baz"></foo.bar>;
    }
    ```
  - `JSXAttributeValue` : 속성의 키에 할당할 수 있는 값
    - "큰따옴표로 구성된 문자열"
    - '작은따옴표로 구성된 문자열'
    - `{ AssignmentExpression }` : 자바스크립트에서 값을 할당할 때 쓰는 표현식
      - 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능
    - `JSXElement` : 다른 JSX 요소가 들어갈 수 있음
      ```js
      <Child attribute=<div>hello</div> />
      ```
  - `JSXFragment` : 값으로 별도 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있음
    - 비어 있는 형태의 `<></>` 허용

### JSXChildren

- `JSXElement`의 자식 값을 나타냄

#### JSXChild

- `JSXChildren`을 이루는 기본 단위, 0개 이상을 가질 수 있음
- `JSXTest` : {, <, >, }을 제외한 문자열 가능
  - 다른 JSX 문법과 혼동을 줄 수 있기 때문
- `JSXElement` : 값으로 다른 JSX 요소가 들어갈 수 있음
- `JSXFragment` : 값으로 빈 JSX 요소인 `<></>`가 들어갈 수 있음
- `{ JSXChildExpression (optional) }` : `JSXChildExpression`는 자바스크립트의 `AssignmentExpression`을 의미
  ```js
  export default function App() {
    return <>{(() => "foo")()}</>;
  }
  ```

### JSXStrings

- HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있음

## 2.1.2 JSX 예제

#### 유효한 형태의 JSX

```js
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕</A>

 // 자식이 없이 SelfClosingTag로 닫혀 있는 형태
 const ComponentB = <A />

 // 옵션을 { }와 전개 연산자로 넣을 수 있음
 const ComponentC = <A {...{ required: true }} />

 // 속성만 넣어도 가능
 comst ComponentD = <A required />

 // 속성과 속성값을 넣을 수 있음
 comst ComponentE = <A required = {fasle} />

 // 문자열 "", '' 가능
 cosnt ComponentF = (
    <A>
        <B text = "react" />
    </A>
 )

 // 옵션의 값으로 JSXElement 넣는 것 가능
 cosnt ComponentG = (
    <A>
        <B optionalChildren = {<>안녕하세요</>} />
    </A>
 )

 // 여러 개의 자식도 가능
 cosnt ComponentH = (
    <A>
        안녕하세요
        <B text = "react" />
    </A>
 )
```

## 2.1.3 JSX는 어떻게 자바스크립트에서 변환할까?

- JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인
  - `JSXElement`를 첫 번째 인수로 선언해 요소를 정의
  - 옵셔널인 `JSXChildren`, `JSXAttributes`, `JSXStrings`는 이후 인수로 넘겨주어 처리

#### JSX가 변환되는 특성을 활용

- `JSXElement`만 다르고 `JSXChildren`, `JSXAttributes`가 완전히 동일한 상황에서 중복 코드를 최소화할 수 있음

```js
// X
// props 여부에 따라 children 요소만 달라지는 경우
// 중복 코드 및 번거로운 삼항 연산자 처리 필요 없음
import { createElement, PropsWithChildren } from "react";

function TextOrHeading({
  isHeading,
  children,
}: PropsWithCHildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// O
// JSX가 변환되는 특성을 활용
import { createElement } from "react";

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "hi" : "span",
    { className: "text" },
    children
  );
}
```

# 2.2 가상 DOM과 리액트 파이버

## 2.2.1 DOM과 브라우저 렌더링

- DOM(Document Object Model)

  - 웹페이지에 대한 인터페이스
  - 브라우저에서 웹을 어떻게 보여줄지에 대한 정보

- DOM과 CSSOM으로 렌더링 트리가 만들어지는 과정
  - 1. 브라우저가 주소를 방문해 HTML 파일 다운로드
  - 2. 브라우저의 렌더링 엔진은 HTML을 파싱 -> DOM 생성
  - 3. 2번에서 CSS 만나면 CSS 다운로드
  - 4. 브라우저 렌더링 엔진은 CSS 파싱 -> CSSOM 생성
  - 5. 브라우저는 사용자 눈에 보이는 노드만 방문
  - 6. 눈에 보이는 노드에 대한 cssom 정보 찾음 -> DOM 노드에 CSS 적용
    - 레이아웃(layout, reflow) : 브라우저 화면의 어느 좌표에 그리기 위해 계산하는 과정
    - 페인팅(painting) : 실제 유효한 모습을 그리는 과정

## 2.2.2 가상 DOM의 탄생 배경

- 가상 DOM의 탄생 : 싱글 페이지에서 실시간 변경되는 DOM을 관리하는데 큰 비용 발생했기 때문
- 가상 DOM : 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM(react-dom)
- 가상 DOM은 실제 DOM보다 빠른가?
  - 무조건 빠른 것은 아니고 대부분의 상황에서 애플리케이션을 만들 정도로 충분히 빠르다는 것
- 따라서, 가상 DOM은 브라우저의 DOM을 빠르게 반영하는 것이 아닌 값으로 UI를 표현하는 것

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

### 리액트 파이버

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 가상 DOM과 실제 DOM 비교 -> 변경 사항 수집 -> 변경사항 있을 경우 변경 정보를 가진 파이버를 기준으로 화면에 렌더링 요청
- 파이버가 일하는 과정
  - 1. 렌더 단계 => 비동기 처리
    - 작업을 작은 단위로 분할 -> 우선순위 매김
    - 작업을 중지하거나 재시작 가능
    - 이전 작업을 재사용하거나 폐기 가능
      -> 하나의 작업 단위로 구성된 파이버를 처리 한 후 마무리하는 `finishedWork()` 작업으로 마무리
  - 2. 커밋 단계(`commitWork()`) => 동기 처리(중단 불가)
    - `finishedWork()`에서 얻어진 정보를 바탕으로 커밋 반영
- 따라서,
  - 파이버는 리액트 컴포넌트에 대한 정보를 1:1 가지고 있음 -> 비동기
    - 실제 DOM에 반영할 때는 동기적으로 이루어짐
  - 파이버가 객체로 관리하고 있듯이 리액트에서도 화면에 표시되는 UI를 값으로 관리하고 있음

### 리액트 파이버 트리

- 2개의 트리 존재
  - 현재 모습을 담은 `current` 트리
  - 작업 중인 상태를 나타내는 `workInProgress` 트리
- 더블 버퍼링
  - 보이지 않는 곳에서 다음 그림을 미리 그린 후, 완성되면 현재 상태로 바꾸는 기법
    - 리액트에서도 불완전한 트리를 보여주지 않기 위해 사용
  - 리액트 파이버의 작업이 끝나면 포인터만 변경해 `workInProgress` 트리를 `current` 트리로 변경
- 따라서, 화면에 불완전한 상태로 보일 가능성이 높기 때문에 더블 버퍼링으로 보여짐

### 파이버의 작업 순서

- 1. 리액트는 `beingWork()` 함수 실행해 파이버 작업 수행
  - 자식이 없는 파이버를 만날 때까지
- 2. 1번 작업 끝난 후, `completWork()` 함수 실행 -> 파이버 작업 완료
- 3. 형재가 있으면 형재로 넘어감
- 4. 2, 3번 완료 후, return으로 돌아가 자기 자신 완료됐음을 알림

> 이 과정에서 `setState` 등의 업데이트가 발생하면?
>
> - 우선 current 트리 보여주고, 업데이트 요청 받아 workInProgress 트리를 다시 빌드하여 반영
> - 우선순위에 맞게 작업 완료

## 2.2.4 파이버와 가상 DOM

- 파이버와 가상 DOM은 동일한 개념이 아님
  - 가상 DOM : 오직 웹에서만 통용
  - 파이버 : 브라우저가 아닌 환경(리액트 네이티브)에서도 사용 가능
    - 리액트와 리액트 네이티브 렌더러가 달라도 내부적으로 파이버를 통해 조정되는 과정은 동일
