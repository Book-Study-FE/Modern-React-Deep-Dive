## 2.1 JSX란?

### 2.1.1 JSX의 정의

#### 1) JSXElement

- JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 함
- JSXElement가 되기 위한 형태

  - JSXOpeningElement: 일반적으로 볼 수 있는 요소. JSXOpeningElement로 시작했다면 후술할 JSXClosingElement가 동일한 요소로 같은 단계에서 선언돼 있어야 올바른 JSX 문법으로 간주됨
    - 예: <JSXElement JSXAttributes(optional)>
  - JSXClosingElement: JSXOpeningElement가 종료됐음을 알리는 요소로, 반드시 JSXOpeningElement와 쌍으로 사용돼야 함
    - 예: </JSXElement>
  - JSXSelfClosingElement: 요소가 시작되고, 스스로 종료되는 형태를 의미. `<script/>`와 동일한 모습을 띠고 있으며 이는 내부적으로 자식을 포함할 수 없는 형태를 의미
    - 예: <JEXElement JSXAttributes(optional)>
  - JSXFragment: 아무런 요소가 없는 형태로, JSXSelfClosingElement 형태를 띨 수는 없음. </>는 불가능하지만 <></>는 가능함
    - 예: <>JSXChildren(optional)</>

- 요소명은 대문자로만 시작해야만 되는 거 아니었나요?

  - 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서 반드시 대문자로 시작하는 컴포넌트를 만들어야만 사용 가능함

  ```tsx
  function hello(text) {
    return <div>hello {text}</div>;
  }

  export function App() {
    // 아래 코드는 HTML 태그로 인식되어 정상적으로 실행되지 않는다.
    // Property 'hello' does not exist on type 'JSX.IntrinsicElements'
    return <hello text="안녕하세요" />;
  }
  ```

  - textarea, a, span과 같이 현존하는 HTML 태그만 필터링해 처리하지 않고 위와 같은 규칙을 둔 이유는 미래에 추가되는 HTML에 대한 가능성을 열어두고 사람이 확실하게 구별할 수 있는 차이점을 두기 위한 것으로 보임

  ##### 1. JSXElementName

  - JSXElement의 요소 이름으로 쓸 수 있는 것을 의미
  - 이름으로 가능한 목록

    - JSXIdentifier: JSX 내부에서 사용할 수 있는 식별자 의미. 이는 자바스크립트 식별자 규칠과 동일. 즉, `<$></$>` `<_></_>`도 가능하지만 자바스크립트와 마찬가지로 숫자로 시작하거나 $와 \_ 외의 다른 특수문자로는 시작할 수 없음

    ```tsx
    function Valid1() {
        return <$></$>
    }

    function Valid2() {
        return <_></_>
    }

    // 불가능
    function Invalid1() {
        return <1></1>
    }
    ```

    - JSXNamespacedName: JSXIdentifier:JSXIdentifier의 조합. 즉, :을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급됨. :로 묶을 수 있는 것은 한 개뿐. 두 개 이상은 올바른 식별자로 취급되지 않음

    ```tsx
    function Valid() {
        return <foo:bar></foo:bar>
    }

    // 불가능하다
    function invalid() {
        return <foo:bar:baz></foo:bar:baz>
    }
    ```

    - JSXMemberExpression: JSXIdentifier.JSXIdentifier의 조합. 즉 .을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급됨. :로 묶는 JSXNamespacedName과는 다르게 .을 여러 개 이어서 하는 것도 가능하지만 JSXNamespacedName과 이어서 사용하는 것은 불가능

    ```tsx
    function valid1() {
      return <foo.bar></foo.bar>;
    }

    function valid2() {
      return <foo.bar.baz></foo.bar.baz>;
    }

    // 불가능하다
    function invalid() {
      return <foo:bar.baz></foo:bar.baz>;
    }
    ```

#### 2) JSXAttributes

- JSXElement에 부여할 수 없는 속성 의미. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않음

  - JSXSpreadAttributes: 자바스크립트의 전개 연산자와 동일한 역할을 한다고 볼 수 있음
    - {...AssignmentExpression}: 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있음. 여기에는 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함돼 있음
  - JSXAttribute: 속성을 나타내는 키와 값으로 짝을 이루어서 표현함. 키는 JSXAttributeName, 값은 JSXAttributeValue로 불림
    - JSXAttributeName: 속성의 키 값. 키로는 앞서 JSXElementName에서 언급했던 JSXIdentifier와 JSXNamespacedName이 가능함. 여기서도 마찬가지로 :을 이용해 키를 나타낼 수 있음
    ```tsx
    function valid1() {
      return <foo.bar foo:bar="baz"></foo.bar>;
    }
    ```
  - JSXAttributeValue: 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 함

    - "큰따옴표로 구성된 문자열": 자바스크립트의 문자열과 동일. 안에 아무런 내용이 없어도 상관없음
    - '작은따옴표로 구성된 문자열': 자바스크립트의 문자열과 동일. 안에 아무런 내용이 없어도 상관없음
    - {AssignmentExpression}: 자바스크립트의 AssignmentExpression을 의미. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말함. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있음. 리액트에서 자주 볼 수 없는 코드지만 다음과 같은 형태도 가능

    ```tsx
    function Child({ attribute }) {
      return <div>{attribute}</div>;
    }

    export default function App() {
      return (
        <div>
          <Child attribute=<div>hello</div> />
        </div>
      );
    }
    ```

    - 대부분의 리액트 개발자들은 `<Child attribute={<div>hello</div>}` />와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 걸 보는 것이 더 익숙할텐데, 사실 이건 문법적인 오류가 아닌 prettier의 규칙. 이 prettier의 규칙은 태그가 포함된 JSX 구문을 좀 더 읽기 쉽게 만들기 위해 제공됨
    - JSXFragment: 값으로 별도 속성을 갖지 않는 형태의 JSX의 요소가 들어갈 수 있음. 즉, 비어 있는 형태의 <></>가 허용됨

#### 3) JSXChildren

- JSXElement의 자식 값을 나타냄
- JSX는 앞서 언급했듯 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 함
  - JSXChild: JSXChildren을 이루는 기본 단위. 단어의 차이에서 알 수 있듯이 JSXChildren은 JSXChild를 0개 이상 가질 수 있음. 0개 이상이라는 의미에서 알 수 있는 것처럼 JSXChildren은 JSXChild가 없어도 상관 없음
    - JSXText: {, <, >, }을 제외한 문자열. 이는 다른 JSX 문법과 혼동을 줄 수 있기 때문. 만약 이 문자를 표현하고 싶다면 문자열로 표시하는 방법이 있음
    ```tsx
    function valid() {
      return <>{"{} <>"}</>;
    }
    ```
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있음
    - JSXFragment: 값으로 빈 JSX 요소인 <></>가 들어갈 수 있음
    - {JSXChildExpression(optional)}: 이 JSXChildExpression은 자바스크립트의 AssignmentExpression을 의미. 익숙하지 않겠지만 다음과 같은 코드도 올바른 JSX 표현식으로 볼 수 있음
    ```jsx
    // 이 함수를 리액트에서 렌더링하면 "foo"라는 문자열이 출력됨
    export default function App() {
      return <>{() => "foo"}</>;
    }
    ```

#### 4) JSXStrings

- 앞서 소개한 JSXAttributeValue와 JSXText는 HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계되어 있음
- HTML에서 사용 가능한 문자열은 JSXStrings에서도 가능. 이는 개발자가 HTML의 내용을 손쉽게 JSX로 가져올 수 있도록 의도적으로 설계된 부분
- 여기서 정의 문자열이라 함은, "큰따옴표로 구성된 문자열", '작은따옴표로 구성된 문자열' 혹은 JSXText 의미
- 자바스크립트와의 한 가지 중요한 차이점

  - \로 시작하는 이스케이프 문자 연태소.
  - \는 자바스크립트에서 특수문자를 처리할 때 사용되므로 몇 가지 제약 사항(\를 표현하기 위해서는 \\로 이스케이프해야 함)이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있음

  ```tsx
  <!-- \을 사용하는 데 문제가 없다. -->
  <button>\</button>
  // Uncaught SyntaxError: Invalid or unexpected token
  let escape1 = "\"

  // ok
  let escape2 = "\\"
  ```

- HTML과 JSX 사이에 복사/붙여넣기를 쉽게 하기 위해 현재의 JSX는 HTML처럼 \을 이스케이프 문자열로 처리하고 있지 않음. JSX 2.0이 나오지 않는 이상 수정되지 쉽지 않아 보임

### 2.1.2 JSX 예제

```jsx
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕하세요.</A>;

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태도 가능함
const ComponentB = <A />;

// 옵션을 { }와 전개 연산자로 넣을 수 있음
const ComponentC = <A {...{ required: true }} />;

// 속성만 넣어도 가능
const ComponentD = <A requred />;

// 속성과 속성값을 넣을 수 있음
const ComponentE = <A required={false} />;

const ComponentF = (
  <A>
    {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능 */}
    <B text="리액트" />
  </A>
);

const ComponentG = (
  <A>
    {/* 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법 */}
    <B optionalChildren={<>안녕하세요.</>} />
  </A>
);

const ComponentH = (
  <A>
    {/* 여러 개의 자식도 포함할 수 있음 */}
    안녕하세요.
    <B text="리액트 " />
  </A>
);
```

- 이 외에도 리액트 내에서는 유효하지 않거나 사용되는 경우가 거의 없는 문법도 JSX 묹법 자체로는 유효함

```tsx
function ComponentA() {
  return <A.B></A.B>;
}

function ComponentB() {
  return <A.B.C></A.B.C>;
}

function ComponentC() {
  return <A:B.C></A:B.C>;
}

function ComponentD() {
  return <$></$>;
}

function ComponentE() {
  return <_></_>;
}
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- 자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인을 알아야 함. 이 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환함

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
);
```

- 위의 코드를 변환한 결과

```jsx
"use strict";

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  "Hello World"
);
var ComponentB = React.createElement(React.Fragment, null, "Hello World");
var ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

```jsx
'use strict";

var _jsxRuntime = require('custom-jsx-library/jsx-runtime');

var ComponentA = (0, _jsxRuntime.jsx)(A, {
    required: true,
    children: 'Hello World',
})
var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: 'Hello World',
})
var ComponentC = (0, _jsxRuntime.jsx)('div', {
    children: (0, _jsxRuntime.jsx)('span', {
        children; 'hello world'
    }),
}
```
