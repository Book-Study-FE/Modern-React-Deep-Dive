## 2.1 JSX란?

### 2.1.1 JSX의 정의

#### 1) JSXElement

- JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 함
- JSXElement가 되기 위한 형태

  - JSXOpeningElement: 일반적으로 볼 수 있는 요소. JSXOpeningElement로 시작했다면 후술할 JSXClosingElement가 동일한 요소로 같은 단계에서 선언돼 있어야 올바른 JSX 문법으로 간주됨
    - 예: <JSXElement JSXAttributes(optional)>
  - JSXClosingElement: JSXOpeningElement가 종료됐음을 알리는 요소로, 반드시 JSXOpeningElement와 쌍으로 사용돼야 함
    - 예: </JSXElement>
  - JSXSelfClosingElement: 요소가 시작되고, 스스로 종료되는 형태를 의미. `<script/>`와 동일한 모습을 띠고 있으며 이는 내부적으로 자식을 포함할 수 없는 형태를 의미
    - 예: <JEXElement JSXAttributes(optional)>
  - JSXFragment: 아무런 요소가 없는 형태로, JSXSelfClosingElement 형태를 띨 수는 없음. </>는 불가능하지만 <></>는 가능함
    - 예: <>JSXChildren(optional)</>

- 요소명은 대문자로만 시작해야만 되는 거 아니었나요?

  - 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서 반드시 대문자로 시작하는 컴포넌트를 만들어야만 사용 가능함

  ```tsx
  function hello(text) {
    return <div>hello {text}</div>;
  }

  export function App() {
    // 아래 코드는 HTML 태그로 인식되어 정상적으로 실행되지 않는다.
    // Property 'hello' does not exist on type 'JSX.IntrinsicElements'
    return <hello text="안녕하세요" />;
  }
  ```

  - textarea, a, span과 같이 현존하는 HTML 태그만 필터링해 처리하지 않고 위와 같은 규칙을 둔 이유는 미래에 추가되는 HTML에 대한 가능성을 열어두고 사람이 확실하게 구별할 수 있는 차이점을 두기 위한 것으로 보임

  ##### 1. JSXElementName

  - JSXElement의 요소 이름으로 쓸 수 있는 것을 의미
  - 이름으로 가능한 목록

    - JSXIdentifier: JSX 내부에서 사용할 수 있는 식별자 의미. 이는 자바스크립트 식별자 규칠과 동일. 즉, `<$></$>` `<_></_>`도 가능하지만 자바스크립트와 마찬가지로 숫자로 시작하거나 $와 \_ 외의 다른 특수문자로는 시작할 수 없음

    ```tsx
    function Valid1() {
        return <$></$>
    }

    function Valid2() {
        return <_></_>
    }

    // 불가능
    function Invalid1() {
        return <1></1>
    }
    ```

    - JSXNamespacedName: JSXIdentifier:JSXIdentifier의 조합. 즉, :을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급됨. :로 묶을 수 있는 것은 한 개뿐. 두 개 이상은 올바른 식별자로 취급되지 않음

    ```tsx
    function Valid() {
        return <foo:bar></foo:bar>
    }

    // 불가능하다
    function invalid() {
        return <foo:bar:baz></foo:bar:baz>
    }
    ```

    - JSXMemberExpression: JSXIdentifier.JSXIdentifier의 조합. 즉 .을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급됨. :로 묶는 JSXNamespacedName과는 다르게 .을 여러 개 이어서 하는 것도 가능하지만 JSXNamespacedName과 이어서 사용하는 것은 불가능

    ```tsx
    function valid1() {
      return <foo.bar></foo.bar>;
    }

    function valid2() {
      return <foo.bar.baz></foo.bar.baz>;
    }

    // 불가능하다
    function invalid() {
      return <foo:bar.baz></foo:bar.baz>;
    }
    ```

#### 2) JSXAttributes

- JSXElement에 부여할 수 없는 속성 의미. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않음

  - JSXSpreadAttributes: 자바스크립트의 전개 연산자와 동일한 역할을 한다고 볼 수 있음
    - {...AssignmentExpression}: 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있음. 여기에는 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함돼 있음
  - JSXAttribute: 속성을 나타내는 키와 값으로 짝을 이루어서 표현함. 키는 JSXAttributeName, 값은 JSXAttributeValue로 불림
    - JSXAttributeName: 속성의 키 값. 키로는 앞서 JSXElementName에서 언급했던 JSXIdentifier와 JSXNamespacedName이 가능함. 여기서도 마찬가지로 :을 이용해 키를 나타낼 수 있음
    ```tsx
    function valid1() {
      return <foo.bar foo:bar="baz"></foo.bar>;
    }
    ```
  - JSXAttributeValue: 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 함

    - "큰따옴표로 구성된 문자열": 자바스크립트의 문자열과 동일. 안에 아무런 내용이 없어도 상관없음
    - '작은따옴표로 구성된 문자열': 자바스크립트의 문자열과 동일. 안에 아무런 내용이 없어도 상관없음
    - {AssignmentExpression}: 자바스크립트의 AssignmentExpression을 의미. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말함. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있음. 리액트에서 자주 볼 수 없는 코드지만 다음과 같은 형태도 가능

    ```tsx
    function Child({ attribute }) {
      return <div>{attribute}</div>;
    }

    export default function App() {
      return (
        <div>
          <Child attribute=<div>hello</div> />
        </div>
      );
    }
    ```

    - 대부분의 리액트 개발자들은 `<Child attribute={<div>hello</div>}` />와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 걸 보는 것이 더 익숙할텐데, 사실 이건 문법적인 오류가 아닌 prettier의 규칙. 이 prettier의 규칙은 태그가 포함된 JSX 구문을 좀 더 읽기 쉽게 만들기 위해 제공됨
    - JSXFragment: 값으로 별도 속성을 갖지 않는 형태의 JSX의 요소가 들어갈 수 있음. 즉, 비어 있는 형태의 <></>가 허용됨

#### 3) JSXChildren

- JSXElement의 자식 값을 나타냄
- JSX는 앞서 언급했듯 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 함
  - JSXChild: JSXChildren을 이루는 기본 단위. 단어의 차이에서 알 수 있듯이 JSXChildren은 JSXChild를 0개 이상 가질 수 있음. 0개 이상이라는 의미에서 알 수 있는 것처럼 JSXChildren은 JSXChild가 없어도 상관 없음
    - JSXText: {, <, >, }을 제외한 문자열. 이는 다른 JSX 문법과 혼동을 줄 수 있기 때문. 만약 이 문자를 표현하고 싶다면 문자열로 표시하는 방법이 있음
    ```tsx
    function valid() {
      return <>{"{} <>"}</>;
    }
    ```
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있음
    - JSXFragment: 값으로 빈 JSX 요소인 <></>가 들어갈 수 있음
    - {JSXChildExpression(optional)}: 이 JSXChildExpression은 자바스크립트의 AssignmentExpression을 의미. 익숙하지 않겠지만 다음과 같은 코드도 올바른 JSX 표현식으로 볼 수 있음
    ```jsx
    // 이 함수를 리액트에서 렌더링하면 "foo"라는 문자열이 출력됨
    export default function App() {
      return <>{() => "foo"}</>;
    }
    ```

#### 4) JSXStrings

- 앞서 소개한 JSXAttributeValue와 JSXText는 HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계되어 있음
- HTML에서 사용 가능한 문자열은 JSXStrings에서도 가능. 이는 개발자가 HTML의 내용을 손쉽게 JSX로 가져올 수 있도록 의도적으로 설계된 부분
- 여기서 정의 문자열이라 함은, "큰따옴표로 구성된 문자열", '작은따옴표로 구성된 문자열' 혹은 JSXText 의미
- 자바스크립트와의 한 가지 중요한 차이점

  - \로 시작하는 이스케이프 문자 연태소.
  - \는 자바스크립트에서 특수문자를 처리할 때 사용되므로 몇 가지 제약 사항(\를 표현하기 위해서는 \\로 이스케이프해야 함)이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있음

  ```tsx
  <!-- \을 사용하는 데 문제가 없다. -->
  <button>\</button>
  // Uncaught SyntaxError: Invalid or unexpected token
  let escape1 = "\"

  // ok
  let escape2 = "\\"
  ```

- HTML과 JSX 사이에 복사/붙여넣기를 쉽게 하기 위해 현재의 JSX는 HTML처럼 \을 이스케이프 문자열로 처리하고 있지 않음. JSX 2.0이 나오지 않는 이상 수정되지 쉽지 않아 보임

### 2.1.2 JSX 예제

```jsx
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕하세요.</A>;

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태도 가능함
const ComponentB = <A />;

// 옵션을 { }와 전개 연산자로 넣을 수 있음
const ComponentC = <A {...{ required: true }} />;

// 속성만 넣어도 가능
const ComponentD = <A requred />;

// 속성과 속성값을 넣을 수 있음
const ComponentE = <A required={false} />;

const ComponentF = (
  <A>
    {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능 */}
    <B text="리액트" />
  </A>
);

const ComponentG = (
  <A>
    {/* 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법 */}
    <B optionalChildren={<>안녕하세요.</>} />
  </A>
);

const ComponentH = (
  <A>
    {/* 여러 개의 자식도 포함할 수 있음 */}
    안녕하세요.
    <B text="리액트 " />
  </A>
);
```

- 이 외에도 리액트 내에서는 유효하지 않거나 사용되는 경우가 거의 없는 문법도 JSX 묹법 자체로는 유효함

```tsx
function ComponentA() {
  return <A.B></A.B>;
}

function ComponentB() {
  return <A.B.C></A.B.C>;
}

function ComponentC() {
  return <A:B.C></A:B.C>;
}

function ComponentD() {
  return <$></$>;
}

function ComponentE() {
  return <_></_>;
}
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- 자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인을 알아야 함. 이 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환함

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
);
```

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

- DOM(Document Object Model) : 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있음

- 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정
  1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드
  2. 브라우저가 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만듦
  3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드
  4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만듦
  5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문. 즉, `display: none`과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않음. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위힘
  6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있음
     - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 됨
     - 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
  - 위의 모든 단계를 거치면 최종 출력물은 웹 애플리케이션의 모든 콘텐츠와 스타일 정보를 갖게 됨
- 코드로 위의 과정이 어떻게 일어나는지 살펴보기

  ```jsx
  #text {
    background-color: red
    color: white
  }
  <!DOCTYPE html>
  <html>
    <head>
      <link rel='stylesheet' type='text/css' href='./style.css' />
      <title>Hello React</title>
    </head>
    <body>
      <div style="width: 100%;">
        <div id="text" style="width: 50%;">Hello world!</div>
      </div>
    </body>
  </html>
  ```

  1. HTML을 다운로드. 다운로드와 함께 HTML을 분석하기 시작
  2. 스타일시트가 포함된 link 태그를 발견해 style.css를 다운로드
  3. body 태그 하단의 div는 `width: 100%`이므로 뷰포트(브라우저가 사용자에게 노출하는 영역)로 좌우 100% 너비로 잡음
  4. 3번 하단의 div는 `width: 50%`, 즉 부모의 50%를 너비로 잡아야 하므로 전체 영역의 50%를 너비로 잡음
  5. 2번에서 다운로드한 CSS에 `id="text"`에 대한 스타일 정보를 결합
  6. 화면에 HTML 정보를 그리기 위한 모든 정보가 준비됐으므로 위 정보를 바탕으로 렌더링 수행

### 2.2.2 가상 DOM의 탄생 배경

- 가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미.
- 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영(여기에서 말하는 리액트는 package.json에 있는 react가 아닌 react-dom 의미)
- 리액트의 이런 방식이 일반적인 DOM을 관리하는 브라우저보다 빠르다고 오해하지만, 무조건 빠른 것이 아니라 리액트의 가상 DOM 방식은 대부분의 상황에서 웬만한 애플리케이션을 만들 수있을 정도로 충분히 빠르다는 것
- 리액트는 랜더링 방식에 있어서 브라우저와 개발자에게 도움을 줄 수 있는 가상 DOM 개념을 만들었고, 이는 애플리케이션을 개발할 수 있을 만큼 합리적으로 빠르기 때문에 채용한 것

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버(React Fiber)

#### 1) 리액트 파이버란?

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 재조정자(fiber reconciler)가 관리하는데, 이는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 함
- 재조정: 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)
- 목표: 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것
  - 이를 해결하기 위해 파이버가 하는 일
    - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위 매김
    - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있음
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있음
- 이러한 모든 과정은 비동기로 일어남
- 파이어는 어떻게 구현되어 있는가?
  - 파이버는 하나의 작업 단위로 구성되어 있음
  - 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리 함
  - 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 냄
    1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업 수행. 그리고 이 단계에서 앞서 언급한 파이버의 직업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업 일어남
    2. 커밋 단계에서는 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 있음
- 파이버는 리액트 요소와 유사하다고 느낄 수 있지만, 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다는 차이점이 있음
- 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행
- 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다는 것. 즉, 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 가능한 한 빠르게 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리

#### 2) 리액트 파이버 트리

- 현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리 두 개가 존재함
- 더블 버퍼링: 리액트 파이버의 작업이 끝나면 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버림
- 미처 다 그리지 못한 모습을 노출시키지 않기 위해(불완전한 트리를 보여주지 않기 위해) 더블 버퍼링 기법 사용
- 더블 버퍼링은 커밋 단계에서 수행됨

#### 3) 파이버의 작업 순서

- 일반적인 파이버 노드의 생성 흐름

  1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작
  2. 1번에서 작업이 끝나면 그 다음 completeWork() 함수를 실행해 파이버 작업 완료
  3. 형제가 있다면 형제로 넘어감
  4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알림

- 예제 코드

```jsx
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
  <B3 />
</A1>
```

1. A1의 beginWork() 수행
2. A1은 자식이 있으므로 B1으로 이동해 beginWord() 수행
3. B1은 자식이 없으므로 completeWork() 수행. 자식은 없으므로 형제인 B2로 넘어감
4. B2의 beginWork() 수행. 자식이 있으므로 C1으로 이동
5. C1의 beginWork() 수행. 자식이 있으므로 D1으로 이동
6. D1의 beginWork() 수행
7. D1은 자식이 없으므로 completeWork() 수행. 형제인 D2로 넘어감
8. D2는 자식이 없으므로 completeWork() 수행
9. D2는 자식도 형제도 없으므로 위로 이동해 D1, C1, B2 순으로 completeWork() 호출
10. B2는 형제인 B3로 이동해 beginWork() 수행
11. B3의 completeWork() 수행되면 반환해 상위로 타고 올라감
12. A1의 completeWork() 수행
13. 루드 노트가 완성되는 순간, 최종적으로 commitWork() 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사앙이 DOM에 반영됨

### 2.2.4 파이버와 가상 DOM

- 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버, 리액트 아키텍처 내부에서 비동기로 이루어짐
- 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상(메모리상)에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용
- 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기 때문에 파이버와 가상 DOM은 동일 개념 아님
